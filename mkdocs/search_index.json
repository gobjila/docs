{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\n\n\nWhat is BackBee ?\n\n\nBackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.\n\n\nWhat is an On-page Editing Site?\n\n\nOn-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.\n\n\nWhat's this means?\n\n\nIn most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.\n\n\nBackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.\n\n\nWhat\u2019s so interesting about this?\n\n\nIt's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.\n\n\nThe majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.\n\n\nKey concepts\n\n\n\n\nIt\u2019s unimaginably easy to use.\n\n\nResponsive design is native to the app.\n\n\nIt\u2019s super flexible in terms of graphic design, workflow, SEO and user access.\n\n\nIt's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.\n\n\nIt\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-backbee", 
            "text": "BackBee is an open source Content Management System (CMS) with one major advantage. BackBee uses On-page Editing Technology (OET) which means you can easily create and manage websites as they appear with no prior technical knowledge.  What is an On-page Editing Site?  On-page Editing Technology (OET) is the natural evolution of your usual Content Management System functionalities. On-page Editing Technology is a tool that allows you to enter, edit and manage your website directly as it appears to users: The back office and front office are merged.  What's this means?  In most content management systems, you have to shuttle between the back office \u2013 a functional interface \u2013 and a \u201cpreview\u201d mode. This is the only way for you to see what users will.  BackBee\u2019s On-Page Editing Technology lets you directly do all your inputting and editing on the page that appears to users. Therefore you get an immediate and exact idea of what the final page will look like eliminating all unnecessary operations.  What\u2019s so interesting about this?  It's easier and more flexible than your usual CMS. With BackBee's On-page Editing Technology, you can work directly on your HTML page, the page that's visible to users. You can drag and drop page elements and move them around as you wish, adding, deleting or changing text, photos or other page elements by simply clicking on the area in question.  The majority of the editorial functions are present in one single compact toolbar on top of your website page. BackBee is the first CMS to use On-Page editing Technology merging back office and front office.", 
            "title": "What is BackBee ?"
        }, 
        {
            "location": "/#key-concepts", 
            "text": "It\u2019s unimaginably easy to use.  Responsive design is native to the app.  It\u2019s super flexible in terms of graphic design, workflow, SEO and user access.  It's secure, in several senses: it saves changes so that editorial security is guaranteed; it's easy to configure user access and rights; and the BackBee core is very secure, so developers can make contributions fearlessly.  It\u2019s open source, which means it\u2019s constantly being tested and improved.", 
            "title": "Key concepts"
        }, 
        {
            "location": "/developer-documentation/requirements/", 
            "text": "Developer documentation\n\n\nRequirements for running BackBee CMS\n\n\nTo run BackBee CMS, your system needs to fulfill to a list of requirements.\n\n\nHere you will find the list of required and optional requirements.\n\n\nRequired\n\n\nBecause BackBee CMS is built on top of Symfony components, these elements are required.\n\n\n\n\nJSON\n needs to be enabled\n\n\nctype\n needs to be enabled\n\n\nmbstring\n needs to be enabled\n\n\nYour PHP configuration needs to have the date.timezone setting defined\n\n\n\n\nThe minimum version of PHP must be: \nPHP 5.4.0\n.\n\n\nOptional\n\n\n\n\nYou (may) need to have the PHP-XML module installed\n\n\nYou (may) need to have at least version 2.6.21 of libxml\n\n\nYou (may) need to have PHP tokenizer module enabled\n\n\nYou (may) need to have iconv module enabled\n\n\nYou (may) need to have POSIX enabled (only on *nix)\n\n\nYou (may) need to have Intl installed with ICU 4+\n\n\nYou (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)\n\n\nPHP configuration recommended settings:\n\n\n\n\nshort_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off\n\n\n\n\nDoctrine2 (Database management)\n\n\nBecause we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need \nphp5-sqlite\n extension to be installed and enabled during the installation process.", 
            "title": "Requirements"
        }, 
        {
            "location": "/developer-documentation/requirements/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/developer-documentation/requirements/#requirements-for-running-backbee-cms", 
            "text": "To run BackBee CMS, your system needs to fulfill to a list of requirements.  Here you will find the list of required and optional requirements.  Required  Because BackBee CMS is built on top of Symfony components, these elements are required.   JSON  needs to be enabled  ctype  needs to be enabled  mbstring  needs to be enabled  Your PHP configuration needs to have the date.timezone setting defined   The minimum version of PHP must be:  PHP 5.4.0 .  Optional   You (may) need to have the PHP-XML module installed  You (may) need to have at least version 2.6.21 of libxml  You (may) need to have PHP tokenizer module enabled  You (may) need to have iconv module enabled  You (may) need to have POSIX enabled (only on *nix)  You (may) need to have Intl installed with ICU 4+  You (may) need to have APC 3.0.17+ installed (or another opcode cache needs to be installed)  PHP configuration recommended settings:   short_open_tag = Off\n\nmagic_quotes_gpc = Off\n\nregister_globals = Off\n\nsession.auto_start = Off  Doctrine2 (Database management)  Because we depend on Doctrine 2, you will need to have PDO installed. Additionally, you need to have the PDO driver installed to use your database server.\nAlso, you need  php5-sqlite  extension to be installed and enabled during the installation process.", 
            "title": "Requirements for running BackBee CMS"
        }, 
        {
            "location": "/developer-documentation/installation/", 
            "text": "Developer documentation\n\n\nInstallation\n\n\nMake sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developer mode.\n\n\nThird party Software\n\n\nFirst of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and \nPHP 5.4\n.\n\n\nYou need to install \ngit\n and \nComposer\n, the dependency manager for PHP.\n\n\nIf your are on Linux/Unix based (like ubuntu or Mac OS X), follow this \nlink\n for installation. Composer is also available on \nWindows system\n.\n\n\nIn a command line interface, check if \ncomposer\n is correctly installed:\n\n\n\n\nAlso, check your PHP version which should be 5.4 or more.\n\n\n\n\nSet up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into \n/etc/hosts\n file. In our example: \nblogbee.dev\n:\n\n\n127.0.0.1   blogbee.dev\n\n\n\nYou can now launch the installation process.\n\n\nWeb Installer\n\n\nOpen a command line interface and get BackBee:\n\n\n$ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n\n\n\n\nThen on the \npublic\n directory, launch the builtin server of PHP:\n\n\n$ cd /path/to/your/folder/public \n php -S blogbee.dev:8000\n\n\n\nAnd you should see the first installation step of BackBee (access \nhttp://blogbee.dev:8000/install.php\n) in a web browser:\n\n\n\n\nYou need to create \ncache\n and \nlog\n folders with the correct rights, then you can refresh the page and access to the \nsecond step\n of the installer.\n\n\n\n\nIf required, check the \nrepository/Config\n folder rights and then go to the \nthird\n step.\n\n\nYou need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields \ndatabase name\n, \nusername\n and \npassword\n.\n\n\n\n\nYou also need to define your super admin user, fill the credentials then save and continue to the \nfourth\n step.\n\n\n\n\nBackBee Installer creates and populates the database, fill the last fields to complete the installation process: the \nsite_name\n and the \ndomain\n.\n\n\nYou can also check the option \"Create demonstration website\" if you want to install a complete demonstration based on a press website, see \nThe MAG\n.\n\n\n\n\nInstallation is now completed: BackBee gives you the \nApache\n or \nNginx\n configuration you have to set up to be able to use BackBee on the chosen domain.\n\n\n\n\n\n\nWhen your web server is set up, access the site by going to \nhttp://blogbee.dev\n.\n\n\nIf everything is correctly installed, you should see the BackBee welcome message:\n\n\n\n\n\n\nIf you can't see BackBee welcome message, make sure that \ncache\n and \nlog\n folders have the correct rights. (755 or 777)\n\n\n\n\nYou can now enter your new backoffice buy pressing  \nCTRL + ALT + B\n. Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developer-documentation/installation/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/developer-documentation/installation/#installation", 
            "text": "Make sure you have basic knowledge of PHP5, Apache or Nginx and MySQL to install BackBee in developer mode.  Third party Software  First of all, you need to check that your computer has an appropriate working environment for web development. You need at least a web server (Apache, for instance), a database engine (MySQL, PostgreSQL, SQLite, or any PDO-compatible database engine), and  PHP 5.4 .  You need to install  git  and  Composer , the dependency manager for PHP.  If your are on Linux/Unix based (like ubuntu or Mac OS X), follow this  link  for installation. Composer is also available on  Windows system .  In a command line interface, check if  composer  is correctly installed:   Also, check your PHP version which should be 5.4 or more.   Set up a domain name in your operating system.\nOn Unix/Linux based OS, you can add it into  /etc/hosts  file. In our example:  blogbee.dev :  127.0.0.1   blogbee.dev  You can now launch the installation process.  Web Installer  Open a command line interface and get BackBee:  $ composer create-project \"backbee/backbee-standard\" /path/to/your/folder \"1.0\" -n  Then on the  public  directory, launch the builtin server of PHP:  $ cd /path/to/your/folder/public   php -S blogbee.dev:8000  And you should see the first installation step of BackBee (access  http://blogbee.dev:8000/install.php ) in a web browser:   You need to create  cache  and  log  folders with the correct rights, then you can refresh the page and access to the  second step  of the installer.   If required, check the  repository/Config  folder rights and then go to the  third  step.  You need to set your database settings. If you use a different database engine than MySQL or MariaDB, set the correct driver else you have nothing to change, only fill the fields  database name ,  username  and  password .   You also need to define your super admin user, fill the credentials then save and continue to the  fourth  step.   BackBee Installer creates and populates the database, fill the last fields to complete the installation process: the  site_name  and the  domain .  You can also check the option \"Create demonstration website\" if you want to install a complete demonstration based on a press website, see  The MAG .   Installation is now completed: BackBee gives you the  Apache  or  Nginx  configuration you have to set up to be able to use BackBee on the chosen domain.    When your web server is set up, access the site by going to  http://blogbee.dev .  If everything is correctly installed, you should see the BackBee welcome message:    If you can't see BackBee welcome message, make sure that  cache  and  log  folders have the correct rights. (755 or 777)   You can now enter your new backoffice buy pressing   CTRL + ALT + B . Fill the login dialog with the credentials you have set up in the fourth step.", 
            "title": "Installation"
        }, 
        {
            "location": "/developer-documentation/architecture/", 
            "text": "Developer documentation\n\n\nArchitecture\n\n\nBackBee CMS relies on many Symfony components and Doctrine 2.\n\n\nHere is the list of components currently used by BackBee CMS:\n\n\n\n\nConfig\n\n\nConsole\n\n\nDebug\n\n\nDependencyInjection\n\n\nEventDispatcher\n\n\nExpression Language\n\n\nFilesystem\n\n\nHttpFoundation\n\n\nHttpKernel\n\n\nRouting\n\n\nSecurity ACL\n\n\nSecurity Core\n\n\nSecurity HTTP\n\n\nSerializer\n\n\nTranslation\n\n\nValidator\n\n\nYaml\n\n\n(Twig)\n\n\n\n\nBackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.\n\n\nTo understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developer-documentation/architecture/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/developer-documentation/architecture/#architecture", 
            "text": "BackBee CMS relies on many Symfony components and Doctrine 2.  Here is the list of components currently used by BackBee CMS:   Config  Console  Debug  DependencyInjection  EventDispatcher  Expression Language  Filesystem  HttpFoundation  HttpKernel  Routing  Security ACL  Security Core  Security HTTP  Serializer  Translation  Validator  Yaml  (Twig)   BackBee CMS is based on a PHP application (the BackBee \"Core\") which provides a REST API managing all the contents,\nthe users, the media and the security. A REST Javascript client provides user interface.  To understand how BackBee CMS is built, take a look on this schema:", 
            "title": "Architecture"
        }, 
        {
            "location": "/developer-documentation/configuration/", 
            "text": "Developer documentation\n\n\nConfiguration\n\n\nBackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.\n\n\nBootstrap configuration (bootstrap.yml)\n\n\nThis configuration file has only two functions:\n\n\n\n\ndebug\n: set the developer mode: if \ntrue\n, the container is generated at each request.\n\n\ncontainer\n: set the container configuration which have 2 parameters\n\n\ndump_directory\n: set the location of the generated container.\n\n\nautogenerate\n: if true, the container is generated at each request.\n\n\n\n\n\n\n\n\nThe \nautogenerate\n option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.\n\n\nBundles configuration (bundles.yml)\n\n\nTo activate a bundle, you need to register it in this file:\n\n\n# /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar\n\n\n\n\n\nDatabase configuration (doctrine.yml)\n\n\nWe provide a demo sample configuration. You can see all available parameters into the related \nDoctrine configuration of Symfony\n:\n\n\n# /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache\n\n\n\n\n\nSEO Configuration (metadata.yml)\n\n\nThis is where you set up the HTML meta headers you want to configure for each page of BackBee:\n\n\n# /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default: \nbackbee demo website\n\n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']\n\n\n\n\n\nThis configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:\n\n\n\n\nSecurity Configuration (security.yml)\n\n\nYou can set up firewalls and sudoers inside this file. A sudoer is a super administrator:\n\n\n# /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developer-documentation/configuration/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/developer-documentation/configuration/#configuration", 
            "text": "BackBee CMS is powerful and highly configurable.\nIn this section, all the available configurations are broken down by the key (e.g. doctrine) that defines each possible section of your application configuration.  Bootstrap configuration (bootstrap.yml)  This configuration file has only two functions:   debug : set the developer mode: if  true , the container is generated at each request.  container : set the container configuration which have 2 parameters  dump_directory : set the location of the generated container.  autogenerate : if true, the container is generated at each request.     The  autogenerate  option is useful when you want to force the generation of the container in \"production\". Don't forget this option has a performance cost.  Bundles configuration (bundles.yml)  To activate a bundle, you need to register it in this file:  # /repository/Config/bundles.yml\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\ntoolbar: BackBee\\Bundle\\ToolbarBundle\\Toolbar  Database configuration (doctrine.yml)  We provide a demo sample configuration. You can see all available parameters into the related  Doctrine configuration of Symfony :  # /repository/Config/doctrine.yml\ndbal:\n    driver: pdo_mysql # [mysql|pgsql|sqlite]\n    host: localhost\n    port: 3306\n    dbname: backbee\n    user: root\n    password: password\n    charset: utf8\n    collation: utf8_general_ci\n    defaultTableOptions: { collate: utf8_general_ci, engine: InnoDB, charset: utf8 }\norm:\n    auto_mapping: true\n    metadata_cache_driver: apc\n    query_cache_driver:\n        type: service\n        id: my_doctrine_common_cache_service # must be a service or a FQCN\n    result_cache_driver:\n        type: memcache\n        host: localhost\n        port: 11211\n        instance_class: Memcache  SEO Configuration (metadata.yml)  This is where you set up the HTML meta headers you want to configure for each page of BackBee:  # /repository/Config/metadata.yml\nkeywords:\n    name: 'keywords'\n    content:\n        default: 'cms, content manager'\ndescription:\n    name: 'description'\n    content:\n        default:  backbee demo website \n    lang: 'en'\nrobots:\n    name: 'robots'\n    content:\n        default: ''\n        select: ['', 'noindex', 'nofollow', 'noindex, nofollow']  This configuration has a real impact on the toolbar, see the generated SEO form in Page context mode:   Security Configuration (security.yml)  You can set up firewalls and sudoers inside this file. A sudoer is a super administrator:  # /repository/Config/security.yml\nfirewalls:\n    firewall_name: { pattern: ^/, anonymous: null }\nsudoers:\n    username: userId", 
            "title": "Configuration"
        }, 
        {
            "location": "/developer-documentation/project_architecture/", 
            "text": "Developer documentation\n\n\nProject Architecture\n\n\nGlobal Architecture\n\n\nGlobal Architecture is build by default by BackBee, it composes the folders:\n\n\n\n\nbundle\n optional folder, create it only if you want develop your own bundle. By default the bundle is installed into the vendor folder;\n\n\ncache\n optional and can be placed out of the project and his location have to be specified into \nservices.yml\n into the \nConfig\n folder;\n\n\nlog\n same as cache folder;\n\n\npublic\n folder it is the document root of your website;\n\n\nrepository\n The folder where you customize your project (see below);\n\n\nvendor\n folder build by composer where you can find every dependencies.\n\n\n\n\nRepository folder Architecture\n\n\nRepository folder (writhed \nrepository\n) is certainly the most important folder of your project. In this folder you will entirely customize your BackBee project. If you start from standard edition you have some folder available, but you can add lot of more and we are going to enumerate every folder that is possible to add (Take note of you have to respect the Case):\n\n\n\n\nClassContent\n This folder contains your content definitions;\n\n\nConfig\n Here you can find and override each config file of BackBee;\n\n\nController\n In this folder your controller will be automatically auto-loaded;\n\n\nData\n Folder where every uploaded file is stored. As the cache and log folder, data can be moved out of the project by customizing \nservices.yml\n;\n\n\nLayouts\n Layout templates are stored in this folder;\n\n\nListener\n In this folder your Event Listeners will be automatically loaded;\n\n\nResources\n In this folder you put your static files like images, JS scripts and CSS;\n\n\nTemplates\n Folder where you put your helpers into \nhelpers\n subfolder, partials into \npartials\n subfolder and ClassContent templates into \nscripts\n subfolder;\n\n\nTraits\n In this folder your ClassContent's Trait will be automatically loaded;\n\n\nTranslation\n Your translation catalog will automatically loaded in this folder.\n\n\n\n\nContext and repository folder overriding\n\n\nIn BackBee repository folder can be contextualized. You use a contextualized repository when you start your application, it's the first argument in construct method.\n\n\n?php\n$app = new \\BackBee\\Standard\\Application('newContext');\n// ...\n\n\n\n\nIf you initialize your application like this, you have the possibility to extend the entire repository folder. Before will see the repository folder architecture then you can reproduce it into your context.\n\n\nThe context repository has to be created inside the \nrepository\n folder and has to have the same name as the key you pass as first parameter to the Application.\n\n\nAfter this you override the file you want by reproducing the folder path and the file. For the other files, if you have not defined them, they will automatically be inherited.\n\n\nrepository/\n  ClassContent/\n  Config/\n    doctrine.yml\n  Data/\n  Listener/\n  newContext/\n    Config/\n      doctrine.yml\n  Resources/\n  ...\n\n\n\n\nIn this case, doctrine configuration will be overwritten to use an other database for example.\n\n\nrepository/\n  ClassContent/\n    AnContent.yml\n  ...\n  newContext/\n    ClassContent/\n      AnotherContent.yml\n  Resources/\n  ...\n\n\n\n\nIn this case the \"newContext\" instance has access to two types of ClassContent and the default configuration only one.\n\n\nAnd of course you can combine the two examples.", 
            "title": "Project Architecture"
        }, 
        {
            "location": "/developer-documentation/project_architecture/#developer-documentation", 
            "text": "", 
            "title": "Developer documentation"
        }, 
        {
            "location": "/developer-documentation/project_architecture/#project-architecture", 
            "text": "Global Architecture  Global Architecture is build by default by BackBee, it composes the folders:   bundle  optional folder, create it only if you want develop your own bundle. By default the bundle is installed into the vendor folder;  cache  optional and can be placed out of the project and his location have to be specified into  services.yml  into the  Config  folder;  log  same as cache folder;  public  folder it is the document root of your website;  repository  The folder where you customize your project (see below);  vendor  folder build by composer where you can find every dependencies.   Repository folder Architecture  Repository folder (writhed  repository ) is certainly the most important folder of your project. In this folder you will entirely customize your BackBee project. If you start from standard edition you have some folder available, but you can add lot of more and we are going to enumerate every folder that is possible to add (Take note of you have to respect the Case):   ClassContent  This folder contains your content definitions;  Config  Here you can find and override each config file of BackBee;  Controller  In this folder your controller will be automatically auto-loaded;  Data  Folder where every uploaded file is stored. As the cache and log folder, data can be moved out of the project by customizing  services.yml ;  Layouts  Layout templates are stored in this folder;  Listener  In this folder your Event Listeners will be automatically loaded;  Resources  In this folder you put your static files like images, JS scripts and CSS;  Templates  Folder where you put your helpers into  helpers  subfolder, partials into  partials  subfolder and ClassContent templates into  scripts  subfolder;  Traits  In this folder your ClassContent's Trait will be automatically loaded;  Translation  Your translation catalog will automatically loaded in this folder.   Context and repository folder overriding  In BackBee repository folder can be contextualized. You use a contextualized repository when you start your application, it's the first argument in construct method.  ?php\n$app = new \\BackBee\\Standard\\Application('newContext');\n// ...  If you initialize your application like this, you have the possibility to extend the entire repository folder. Before will see the repository folder architecture then you can reproduce it into your context.  The context repository has to be created inside the  repository  folder and has to have the same name as the key you pass as first parameter to the Application.  After this you override the file you want by reproducing the folder path and the file. For the other files, if you have not defined them, they will automatically be inherited.  repository/\n  ClassContent/\n  Config/\n    doctrine.yml\n  Data/\n  Listener/\n  newContext/\n    Config/\n      doctrine.yml\n  Resources/\n  ...  In this case, doctrine configuration will be overwritten to use an other database for example.  repository/\n  ClassContent/\n    AnContent.yml\n  ...\n  newContext/\n    ClassContent/\n      AnotherContent.yml\n  Resources/\n  ...  In this case the \"newContext\" instance has access to two types of ClassContent and the default configuration only one.  And of course you can combine the two examples.", 
            "title": "Project Architecture"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_bundle_administration/", 
            "text": "CookBooks\n\n\nCreate bundle administration\n\n\nConfiguration :\n\n\nTo create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into \nConfig/config.yml\n\n\nDefine your controller\n\n\nbundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController\n\n\n\n\n\n\nYou can declare controller as much as you want.\n\n\n\n\nbundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...\n\n\n\n\nAnd to finish we need to define the entry point of your admin interface.\n\n\nbundle:\n  ...\n  admin_entry_point: doc.index\n\n\n\n\n\n\nThe entry point it's compose by controller name that refer the name you declare in \nadmin_controller\n section, dot separator and action name without the Action key word index refer to \nindexAction\n.\n\n\n\n\nController and Actions\n\n\nYour admin controller class have to extend \nAbstractAdminBundleController\n to work correctly in automated mode.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}\n\n\n\n\n\n\nThis represent the minimum necessary to implement your admin controller.\n\n\n\n\nBy extending \nAbstractAdminBundleController\n your controller can access to lot of methods:\n\n\n\n\ngetApplication()\n Returns current application\n\n\ngetContainer()\nReturns the dependency injection container\n\n\ngetRequest()\n Returns current request\n\n\ngetEntityManager()\n Returns doctrine entity manager\n\n\ngetRepository($entity)\n Returns the repository corresponding of the entity name passed in paramater\n\n\nisGranted($permission, $object)\n Returns true if the current user have the permission to do the action on the object\n\n\ngetTranslator()\n Returns translator object\n\n\nrender($template, $parameters)\n Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.\n\n\ncreateResponse($content, $statusCode, $contentType)\n Generate your own response, $content parameter is the body of the response, $statusCode correspond to the\n\n\nredirect($url, $statusCode)\n Create a redirection response\n\n\nnotifyUser($type, $message)\n Generate an notification on the backoffice to the user there is 3 types availble \nself::NOTIFY_SUCCESS\n (green), \nself::NOTIFY_WARNING\n (orange) and \nself::NOTIFY_ERROR\n (red).\n\n\n\n\nNow you have to implement some actions in your controller by default an action have to return an \nString\n, before we have defined that the entry point of the bundle administration it was do in the \nindexAction\n.\nThe index action return an array of values and need no parameters to work, \nindexAction\n it's compose of an \nfindAll\n and one \nrender\n\n\npublic function indexAction()\n{\n    $docs = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfindAll();\n\n    return $this-\nrender('Doc/Index.twig', ['docs' =\n $docs]);\n}\n\n\n\n\nTo consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.\n\n\npublic function showAction($id)\n{\n    $doc = $this-\ngetRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')-\nfind($id);\n\n    return $this-\nrender('Doc/Doc.twig', ['doc' =\n $doc]);\n}\n\n\n\n\nRouting\n\n\nBy default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this: \nRoute is composed by the bundle name, controller name and action name separated by a dot\n.\n\n\n\n\nIn the case of the method \nshowAction\n from \nDocController\n into \nDocumentationBundle\n the route is equal to \ndocumentation.doc.show\n. \ndocumentation\n matches to the name declared into \nbundle.yml\n file in your global configuration and \ndoc\n is the name you gave to your controller into admin_controller section of your \nconfig.yml\n into your bundle configuration file.\n\n\n\n\n\n\nbundleAdminUrl($route, $parameters)\n this helper generate your URL it need a \"route\" and optionally parameters.\n\n\nbundleAdminLink($route, $parameters, $httpMethod)\n this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.\n\n\nbundleAdminForm($route, $parameters, $httpMethod)\n work like \nbundleAdminLink\n but by default the HTTP method is POST.\n\n\n\n\n\n\nbundleAdminLink\n  \nbundleAdminForm\n generate more than just an URL and it need to be goodly used.\n\n\nbundleAdminUrl\n is required only if you want create an custom system and bypass the automated system.\n\n\n\n\nUsage of the \nbundleAdminLink\n into an template to reach the \nshowAction\n\n\na {{ this.bundleAdminLink(\ndocumentation.doc.show\n, {'id': 1})|raw }}\n\n    Show the first document\n\n/a\n\n\n\n\n\nAnd the result before rendering is:\n\n\na data-bundle=\nlink\n href=\n/bundle/documentation/doc/show/1\n data-http-method=\nread\n\n   Show the first document\n\n/a\n\n\n\n\n\n\n\nAs you can see the id 1 do part of the URL and is not present as query. This is because your \nshowAction\n method require an $id to work and the helper do automatically the matching behind the action and your parameters.\n\n\nIn the case of \nbundleAdminForm\n, this helper work correctly only in \nform\n HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_bundle_administration/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_bundle_administration/#create-bundle-administration", 
            "text": "Configuration :  To create an bundle administration we need to declare some parameters into the bundle configuration. Then open your config file into  Config/config.yml  Define your controller  bundle:\n  ...\n  admin_controller:\n    doc: BackBee\\Bundle\\DocumentationBundle\\Controller\\DocController   You can declare controller as much as you want.   bundle:\n  ...\n  admin_controller:\n    first: BackBee\\Bundle\\DocumentationBundle\\Controller\\FirstController\n    second: BackBee\\Bundle\\DocumentationBundle\\Controller\\SecondController\n    ...  And to finish we need to define the entry point of your admin interface.  bundle:\n  ...\n  admin_entry_point: doc.index   The entry point it's compose by controller name that refer the name you declare in  admin_controller  section, dot separator and action name without the Action key word index refer to  indexAction .   Controller and Actions  Your admin controller class have to extend  AbstractAdminBundleController  to work correctly in automated mode.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Controller;\nuse BackBee\\Bundle\\AbstractAdminBundleController;\n\nclass DocController extends AbstractAdminBundleController\n{\n}   This represent the minimum necessary to implement your admin controller.   By extending  AbstractAdminBundleController  your controller can access to lot of methods:   getApplication()  Returns current application  getContainer() Returns the dependency injection container  getRequest()  Returns current request  getEntityManager()  Returns doctrine entity manager  getRepository($entity)  Returns the repository corresponding of the entity name passed in paramater  isGranted($permission, $object)  Returns true if the current user have the permission to do the action on the object  getTranslator()  Returns translator object  render($template, $parameters)  Returns template parsed and rendered first argument is the template file starting from your rendering folder and $parameters are the variables necessary to render the template.  createResponse($content, $statusCode, $contentType)  Generate your own response, $content parameter is the body of the response, $statusCode correspond to the  redirect($url, $statusCode)  Create a redirection response  notifyUser($type, $message)  Generate an notification on the backoffice to the user there is 3 types availble  self::NOTIFY_SUCCESS  (green),  self::NOTIFY_WARNING  (orange) and  self::NOTIFY_ERROR  (red).   Now you have to implement some actions in your controller by default an action have to return an  String , before we have defined that the entry point of the bundle administration it was do in the  indexAction .\nThe index action return an array of values and need no parameters to work,  indexAction  it's compose of an  findAll  and one  render  public function indexAction()\n{\n    $docs = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- findAll();\n\n    return $this- render('Doc/Index.twig', ['docs' =  $docs]);\n}  To consult one object doc in particular we need an showAction. This action need an identifier to retrieve the good object and render it.  public function showAction($id)\n{\n    $doc = $this- getRepository('BackBee\\Bundle\\DocumentationBundle\\Entity\\Item')- find($id);\n\n    return $this- render('Doc/Doc.twig', ['doc' =  $doc]);\n}  Routing  By default on all application, you to expose some route and do the matching with an controller and an action. In the bundle administration the routing is dynamic and automatic. To generate the URL you have 3 helpers to render the URL into your template.\nImplicit route are defined like this:  Route is composed by the bundle name, controller name and action name separated by a dot .   In the case of the method  showAction  from  DocController  into  DocumentationBundle  the route is equal to  documentation.doc.show .  documentation  matches to the name declared into  bundle.yml  file in your global configuration and  doc  is the name you gave to your controller into admin_controller section of your  config.yml  into your bundle configuration file.    bundleAdminUrl($route, $parameters)  this helper generate your URL it need a \"route\" and optionally parameters.  bundleAdminLink($route, $parameters, $httpMethod)  this helper generate all value necessary to an automated system, it work like the previous helper, but accept an third parameter to specify the HTTP method you want use when the link was cliqued. By default the HTTP method is GET.  bundleAdminForm($route, $parameters, $httpMethod)  work like  bundleAdminLink  but by default the HTTP method is POST.    bundleAdminLink    bundleAdminForm  generate more than just an URL and it need to be goodly used.  bundleAdminUrl  is required only if you want create an custom system and bypass the automated system.   Usage of the  bundleAdminLink  into an template to reach the  showAction  a {{ this.bundleAdminLink( documentation.doc.show , {'id': 1})|raw }} \n    Show the first document /a   And the result before rendering is:  a data-bundle= link  href= /bundle/documentation/doc/show/1  data-http-method= read \n   Show the first document /a    As you can see the id 1 do part of the URL and is not present as query. This is because your  showAction  method require an $id to work and the helper do automatically the matching behind the action and your parameters.  In the case of  bundleAdminForm , this helper work correctly only in  form  HTML tag.", 
            "title": "Create bundle administration"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_commands/", 
            "text": "CookBooks\n\n\nCreate new commands\n\n\nThe Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.\n\n\nAutomatically Registering Commands\n\n\nTo make the console commands available automatically with BackBee, create a\n\nCommand\n directory inside your bundle and create a PHP file suffixed with\n\nCommand.php\n for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create\n\nWelcomeCommand.php\n and add the following to it:\n\n\n// bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            -\nsetName('demo:welcome')\n            -\nsetDescription('Welcome someone')\n            -\naddArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            -\naddOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            -\nsetHelp(\nEOF\nThe \ninfo\n%command.name%\n/info\n command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input-\ngetArgument('name');\n\n        if ($input-\ngetOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output-\nwriteln($text);\n    }\n}\n\n\n\n\nThis command will now automatically be available to run:\n\n\n    $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_commands/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_commands/#create-new-commands", 
            "text": "The Console page of the Components section covers how to create a console application.\nThis cookbook article covers the creation of a command using BackBee Standard Edition.  Automatically Registering Commands  To make the console commands available automatically with BackBee, create a Command  directory inside your bundle and create a PHP file suffixed with Command.php  for each command that you want to provide. For example, if you\nwant to extend the DemoBundle to welcome you from the command line, create WelcomeCommand.php  and add the following to it:  // bundle/WelcomeBundle/Command/WelcomeCommand.php\nnamespace WelcomeBundle\\Command;\n\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Input\\InputArgument;\nuse Symfony\\Component\\Console\\Input\\InputOption;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\n\nuse BackBee\\Console\\AbstractCommand;\n\nclass WelcomeCommand extends AbstractCommand\n{\n    protected function configure()\n    {\n        $this\n            - setName('demo:welcome')\n            - setDescription('Welcome someone')\n            - addArgument(\n                'name',\n                InputArgument::OPTIONAL,\n                'Who do you want to welcome?'\n            )\n            - addOption(\n                'yell',\n                null,\n                InputOption::VALUE_NONE,\n                'If set, the message will yell in uppercase letters'\n            )\n            - setHelp( EOF\nThe  info %command.name% /info  command can welcome someone.\nWith the option ``yell``, the message will be displayed in uppercase letters.\nEOF;\n            )\n        ;\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output)\n    { \n        $text = 'Welcome '.$input- getArgument('name');\n\n        if ($input- getOption('yell')) {\n            $text = strtoupper($text);\n        }\n\n        $output- writeln($text);\n    }\n}  This command will now automatically be available to run:      $ ./backbee demo:welcome Charles", 
            "title": "Create new commands"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_templating_helpers/", 
            "text": "CookBooks\n\n\nCreate new templating Helpers\n\n\nThis cookbook article covers the creation of Renderer helpers using BackBee Standard Edition.\n\n\nTemplating helpers are PHP classes that extend the \nfinal\n class \nBackBee\\Renderer\\AbstractRenderer\\AbstractHelper\n,\nand need to be located in \nrepository/Templates/helpers\n folder in your BackBee application (or in \nTemplates/helpers\n folder in bundles).\n\n\nAs an example, we will create an helper to provide a new \nbb_dump()\n function in templates.\n\n\n\n\nYou need to create class with the same name as the function you want to create, because \n__invoke\n magic function is called.\n\n\n\n\n?php\nnamespace BackBee\\Renderer\\Helper;\n\n/**\n * @author Micka\u00ebl Andrieu \nmickael.andrieu@lp-digital.fr\n\n */\nclass bb_dump extends AbstractHelper\n{\n    /**\n     * Returns dump from template (to ease debug of Class Content rendering)\n     * If Symfony VarDumper is autoaded, use it instead of Doctrine Debug::dump()\n     *\n     * @param  mixin $mixin the variable to dump\n     *\n     * @return string\n     */\n    public function __invoke($mixin)\n    {\n        if (!class_exists('\\Symfony\\Component\\VarDumper\\VarDumper')) {\n            return '\npre\n' . \\Doctrine\\Common\\Util\\Debug::dump($mixin, 2, true, false) . '\n/pre\n';\n        }else {\n            return dump($mixin);\n        }\n    }\n}\n\n\n\n\nThe helper is done and can used directly in all templates.\n\n\n!-- /repository/Templates/scripts/Home/HomeContainer --\n\n\ndiv {{ this.bbcontent(null, {'class': 'container main_containt'})|raw }}\n\n\n    {% if this.getObject().getParamValue('container_title') != '' %}\n        \ndiv class=\nbloc-title-2 triangle-b\n\n          \ndiv class=\nborder-bx2 border-color color-txt-1\n{{ this.getObject().getParamValue('container_title') }}\n/div\n\n        \n/div\n\n    {% endif %}\n\n    {{ this.render(container)|raw }}\n\n    {{ this.bb_dump(this.getObject())|raw }}\n\n/div\n\n\n\n\n\nor, in phtml:\n\n\n!-- in a pHTML template --\n\n\np\n\n\n?php $this-\nbb_dump($this-\ngetObject()); ?\n\n\n/p\n\n\n\n\n\nWill produce, with the \n[Symfony VarDumper](http://symfony.com/doc/current/components/var_dumper/introduction.html)\n added as dependency of project,\nthis output:", 
            "title": "Create new templating helpers"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_templating_helpers/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/create_new_templating_helpers/#create-new-templating-helpers", 
            "text": "This cookbook article covers the creation of Renderer helpers using BackBee Standard Edition.  Templating helpers are PHP classes that extend the  final  class  BackBee\\Renderer\\AbstractRenderer\\AbstractHelper ,\nand need to be located in  repository/Templates/helpers  folder in your BackBee application (or in  Templates/helpers  folder in bundles).  As an example, we will create an helper to provide a new  bb_dump()  function in templates.   You need to create class with the same name as the function you want to create, because  __invoke  magic function is called.   ?php\nnamespace BackBee\\Renderer\\Helper;\n\n/**\n * @author Micka\u00ebl Andrieu  mickael.andrieu@lp-digital.fr \n */\nclass bb_dump extends AbstractHelper\n{\n    /**\n     * Returns dump from template (to ease debug of Class Content rendering)\n     * If Symfony VarDumper is autoaded, use it instead of Doctrine Debug::dump()\n     *\n     * @param  mixin $mixin the variable to dump\n     *\n     * @return string\n     */\n    public function __invoke($mixin)\n    {\n        if (!class_exists('\\Symfony\\Component\\VarDumper\\VarDumper')) {\n            return ' pre ' . \\Doctrine\\Common\\Util\\Debug::dump($mixin, 2, true, false) . ' /pre ';\n        }else {\n            return dump($mixin);\n        }\n    }\n}  The helper is done and can used directly in all templates.  !-- /repository/Templates/scripts/Home/HomeContainer --  div {{ this.bbcontent(null, {'class': 'container main_containt'})|raw }} \n\n    {% if this.getObject().getParamValue('container_title') != '' %}\n         div class= bloc-title-2 triangle-b \n           div class= border-bx2 border-color color-txt-1 {{ this.getObject().getParamValue('container_title') }} /div \n         /div \n    {% endif %}\n\n    {{ this.render(container)|raw }}\n\n    {{ this.bb_dump(this.getObject())|raw }} /div   or, in phtml:  !-- in a pHTML template --  p  ?php $this- bb_dump($this- getObject()); ?  /p   Will produce, with the  [Symfony VarDumper](http://symfony.com/doc/current/components/var_dumper/introduction.html)  added as dependency of project,\nthis output:", 
            "title": "Create new templating Helpers"
        }, 
        {
            "location": "/developer-documentation/cookbooks/customize_error_pages/", 
            "text": "CookBooks\n\n\nCustomize error pages\n\n\nIn BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.\n\n\nIn \"Developper Mode\" BackBee will catch and display a \nbetter\n exception page with a lot of informations\nto help you understand the issue:\n\n\n\n\nIn production, your visitors will see the nice error page provided by BackBee:\n\n\n\n\nError pages can be customized in two different ways depending on your needs:\n\n\n\n\nIf you just want to design the contents and styles of the error pages, you can set your own error templates\n\n\nIf you need total control of exception handling to execute your own logic, create your own ExceptionListener on \nkernel.exception\n event.\n\n\n\n\nUse your own default templates\n\n\nWhen the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.\n\n\nThis ExceptionListener uses the HTTP status code, the \ndebug\n parameter and the following logic to determine the template filename:\n\n\nBackBee provides core templates which are located into \nvendor/backbee/BackBee/Resources/layouts/error\n.\nIf the template for the code status doesn't exist, the default template which be used instead.\n\n\nIn BackBee Standard edition, theses templates are already overriden in the \nToolbarBundle\n. Theses templates are located\ninto \nvendor/backbee/toolbar-bundle/Resources/layouts/error\n folder.\n\n\nIf you want to override theses templates, your application might look like this:\n\n\nrepository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml\n\n\n\n\nIn case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developer-documentation/cookbooks/customize_error_pages/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/customize_error_pages/#customize-error-pages", 
            "text": "In BackBee, thanks to Symfony Debug component all errors are treated as exceptions: pages not found or access unauthorized.\nEach error is triggered by throwing an exception in your code.  In \"Developper Mode\" BackBee will catch and display a  better  exception page with a lot of informations\nto help you understand the issue:   In production, your visitors will see the nice error page provided by BackBee:   Error pages can be customized in two different ways depending on your needs:   If you just want to design the contents and styles of the error pages, you can set your own error templates  If you need total control of exception handling to execute your own logic, create your own ExceptionListener on  kernel.exception  event.   Use your own default templates  When the error page loads, an internal ExceptionListener is used to render a Twig template to show template to the user.  This ExceptionListener uses the HTTP status code, the  debug  parameter and the following logic to determine the template filename:  BackBee provides core templates which are located into  vendor/backbee/BackBee/Resources/layouts/error .\nIf the template for the code status doesn't exist, the default template which be used instead.  In BackBee Standard edition, theses templates are already overriden in the  ToolbarBundle . Theses templates are located\ninto  vendor/backbee/toolbar-bundle/Resources/layouts/error  folder.  If you want to override theses templates, your application might look like this:  repository/\n    Resources/\n        layouts/\n            error/\n                404.phtml\n                500.twig\n                default.phtml  In case you need them, the ExceptionController passes informations to the error template via the error variable.\nIt acts as the original PHP exception so you can access the HTTP status code and exception message.", 
            "title": "Customize error pages"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/", 
            "text": "CookBooks\n\n\nEase debugging with Profiler\n\n\nIn BackBee, in addition to the Symfony Debug which display a \nbetter\n exception page with more informations, we have\naccess to a Profiler which collect a lot of interesting data to help developper understand what is going on.\n\n\nThis article cookbook covers the documentation of actual panels from BackBee Profiler.\n\n\nThe BackBee Profiler is a toolbar available at the bottom of the page when you are in \"development\" mode.\n\n\n\n\nFrom left to right, you access to useful informations:\n\n the \nBackBee CMS\n version and the \nBackBee CMS\n application name;\n\n the code status of the page and the action used to render the page;\n\n the number of logs generated when render this page;\n\n the memory used to render the page (in Mo);\n* the number of database requests and the time spent to execute them.\n\n\nThe \nConfiguration\n panel\n\n\nWhen you click on \nBackBee CMS\n version or application name, you access the \nConfiguration panel\n.\n\n\nIn this panel, informations from BackBee configuration are displayed:\n\n\nProject configuration\n\n\nIn this section, the version of BackBee CMS used, the application name and the environment are displayed.\n\n\nPHP configuration\n\n\nIn this section, the version of PHP used is displayed and informations about cache extensions.\nAlso, click on \"phpinfo\" will give you full informations about your PHP configuration.\n\n\nActives Bundle\n\n\nIn this section are listed all activated bundles (i.e exactly the same results as bundles registered in \nbundles.yml\n file).\n\n\nThe \nRequest\n panel\n\n\nWhen you click on status code or in the action used to render page, you open the \nRequest panel\n.\n\n\nIn this panel, all informations from server and from Symfony Request object are displayed to help you understand the\ninformations used to render your page.\n\n\nAll the informations from PHP super globals related to the Request are displayed.\n\n\n\n\nGET\n and \nPOST\n parameters;\n\n\nRequest attributes from BackBee:\n\n\n_action\n: the action used to render the page;\n\n\n_controller\n: the controller called to render the page;\n\n\n_route\n: the route matched by the uri;\n\n\nuri\n: if not controller was found, return \"\nroot\n\" which means the BackBee \nFrontController\n is used.\n\n\n\n\n\n\nRequest cookies;\n\n\nRequest headers (also availables in debug toolbar from any web browser)\n\n\nRequest content\n\n\nRequest Server parameters:\n\n\nResponse headers;\n\n\n\n\nBut also, the \nSession\n informations and the \nflashes\n messages\n\n\nThe \nRouting\n panel\n\n\nWhen you click on \"Routing\", you open the \nRequest panel\n.\n\n\nIn addition to the \ndebug:routing\n command available in \nDebugBundle\n, the Routing panel provides a global overview of actual routes\nregistered in the application.\n\n\nRoutes are ordered by name, schema and patterns. For each route, the panel list the Controller/action couple called when the route is accessed.\n\n\n\n\nThis is a good way to discover the REST API.\n\n\n\n\nThe \nDatabase\n panel\n\n\nWhen you click on the database icon or in the database informations, you open the \nDatabase panel\n.\n\n\nQueries section\n\n\nThis panel list all Doctrine requests used to render the page with the spending time and the runnable query.\nThis is useful when you want to optimize SQL queries or want to understand why you have a Doctrine error with a \nQueryBuilder\n.\n\n\nDoctrine ORM mapping section\n\n\nIf you create your own entities and want to use Doctrine 2 to save in database, you need set up theses PHP classes.\nThis section display all actual classes managed by Doctrine 2 and if the mapping is correctly set up,\nelse an explicit message is displayed to help you fix the mapping.", 
            "title": "Ease debugging with the Web Profiler"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#ease-debugging-with-profiler", 
            "text": "In BackBee, in addition to the Symfony Debug which display a  better  exception page with more informations, we have\naccess to a Profiler which collect a lot of interesting data to help developper understand what is going on.  This article cookbook covers the documentation of actual panels from BackBee Profiler.  The BackBee Profiler is a toolbar available at the bottom of the page when you are in \"development\" mode.   From left to right, you access to useful informations:  the  BackBee CMS  version and the  BackBee CMS  application name;  the code status of the page and the action used to render the page;  the number of logs generated when render this page;  the memory used to render the page (in Mo);\n* the number of database requests and the time spent to execute them.", 
            "title": "Ease debugging with Profiler"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#the-configuration-panel", 
            "text": "When you click on  BackBee CMS  version or application name, you access the  Configuration panel .  In this panel, informations from BackBee configuration are displayed:  Project configuration  In this section, the version of BackBee CMS used, the application name and the environment are displayed.  PHP configuration  In this section, the version of PHP used is displayed and informations about cache extensions.\nAlso, click on \"phpinfo\" will give you full informations about your PHP configuration.  Actives Bundle  In this section are listed all activated bundles (i.e exactly the same results as bundles registered in  bundles.yml  file).", 
            "title": "The Configuration panel"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#the-request-panel", 
            "text": "When you click on status code or in the action used to render page, you open the  Request panel .  In this panel, all informations from server and from Symfony Request object are displayed to help you understand the\ninformations used to render your page.  All the informations from PHP super globals related to the Request are displayed.   GET  and  POST  parameters;  Request attributes from BackBee:  _action : the action used to render the page;  _controller : the controller called to render the page;  _route : the route matched by the uri;  uri : if not controller was found, return \" root \" which means the BackBee  FrontController  is used.    Request cookies;  Request headers (also availables in debug toolbar from any web browser)  Request content  Request Server parameters:  Response headers;   But also, the  Session  informations and the  flashes  messages", 
            "title": "The Request panel"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#the-routing-panel", 
            "text": "When you click on \"Routing\", you open the  Request panel .  In addition to the  debug:routing  command available in  DebugBundle , the Routing panel provides a global overview of actual routes\nregistered in the application.  Routes are ordered by name, schema and patterns. For each route, the panel list the Controller/action couple called when the route is accessed.   This is a good way to discover the REST API.", 
            "title": "The Routing panel"
        }, 
        {
            "location": "/developer-documentation/cookbooks/ease_debugging_with_profiler/#the-database-panel", 
            "text": "When you click on the database icon or in the database informations, you open the  Database panel .  Queries section  This panel list all Doctrine requests used to render the page with the spending time and the runnable query.\nThis is useful when you want to optimize SQL queries or want to understand why you have a Doctrine error with a  QueryBuilder .  Doctrine ORM mapping section  If you create your own entities and want to use Doctrine 2 to save in database, you need set up theses PHP classes.\nThis section display all actual classes managed by Doctrine 2 and if the mapping is correctly set up,\nelse an explicit message is displayed to help you fix the mapping.", 
            "title": "The Database panel"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_swift_mailer_in_backbee/", 
            "text": "CookBooks\n\n\nUse Swiftmailer in BackBee\n\n\nIntroduction\n\n\nIn BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.\n\n\nConfiguration\n\n\nTo configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder \nrepository/Config\n.\n\n\nThe minimal configuration file is composed of an SMTP and  a port\n\n\nsmtp: localhost\nport: 25\n\n\n\n\nYou can also set up more parameters for more security on SMTP.\n\n\nsmtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword\n\n\n\n\nBasic usage example\n\n\nTo retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener. \nThis is not a good practice to place your business logic into an EventListener\n but it is easier to understand.\n\n\n?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event-\ngetDispatcher()-\ngetApplication();\n\n        // retrieve other informations\n        $site = $application-\ngetSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application-\ngetRenderer()-\npartial(\n                'Email/Email.twig',\n                [\n                    'site_name' =\n $site-\ngetLabel(),\n                    'home_link' =\n $site-\ngetServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application-\ngetSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application-\ngetMailer()-\nsend($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site-\ngetServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message-\naddFrom($from, $site-\ngetLabel());\n        // Set the To addresses\n        $message-\naddTo($from, $site-\ngetLabel());\n        // Give the message a subject\n        $message-\nsetSubject('Something append on ' . $site-\ngetLabel());\n        // Give it the body\n        $message-\nsetBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}\n\n\n\n\nIf you want do more with Swift Mailer, you can find additional documentation on \nSwift Mailer web site", 
            "title": "Use Swift Mailer in BackBee"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_swift_mailer_in_backbee/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_swift_mailer_in_backbee/#use-swiftmailer-in-backbee", 
            "text": "Introduction  In BackBee there is no home made component for mailing. We actually use Swift Mailer library.\nBackBee only provides a way to configure it and get your instance initialized easily.", 
            "title": "Use Swiftmailer in BackBee"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_swift_mailer_in_backbee/#configuration", 
            "text": "To configure Swift Mailer in BackBee you need to create mailer.yml into your global configuration folder  repository/Config .  The minimal configuration file is composed of an SMTP and  a port  smtp: localhost\nport: 25  You can also set up more parameters for more security on SMTP.  smtp: localhost\nport: 587\nusername: mailer_user_identifier\npassword: superSecretPassword  Basic usage example  To retrieve the configured mailer you need an access to your Application.\nYou can start with a new app, but for performances matters prefer use the current Application.\nThe example will be placed in the context of an EventListener.  This is not a good practice to place your business logic into an EventListener  but it is easier to understand.  ?php\nnamespace BackBee\\Bundle\\DocumentationBundle\\Listener;\n\nuse BackBee\\Event\\Event;\nuse BackBee\\Site\\Site;\n\nclass MailerListener\n{\n    public static function onSomethingNeedToBeMailed(Event $event)\n    {\n        // retrieve your current Application\n        $application = $event- getDispatcher()- getApplication();\n\n        // retrieve other informations\n        $site = $application- getSite();\n\n        if ($site instanceof Site) {\n            // render e-mail body by using partial method from the renderer\n            $body = $application- getRenderer()- partial(\n                'Email/Email.twig',\n                [\n                    'site_name' =  $site- getLabel(),\n                    'home_link' =  $site- getServerName(),\n                ]\n            );\n\n            // Build the message\n            $message = static::buildMessage(\n                $body,\n                $application- getSite(),\n            );\n\n            // now get the configured mailer by passing by application and send your message\n            $application- getMailer()- send($message);\n        }\n    }\n\n    /**\n     * E-mail message creation\n     */\n    public static function buildMessage($body, $site)\n    {\n        $from = 'administrator@' . $site- getServerName();\n\n        // Create Swift_Message\n        $message = \\Swift_Message::newInstance();\n        // Set the From address\n        $message- addFrom($from, $site- getLabel());\n        // Set the To addresses\n        $message- addTo($from, $site- getLabel());\n        // Give the message a subject\n        $message- setSubject('Something append on ' . $site- getLabel());\n        // Give it the body\n        $message- setBody($body, 'text/html', 'UTF-8');\n\n        return $message;\n    }\n}  If you want do more with Swift Mailer, you can find additional documentation on  Swift Mailer web site", 
            "title": "Configuration"
        }, 
        {
            "location": "/developer-documentation/cookbooks/layout_creation/", 
            "text": "CookBooks\n\n\nLayout creation using LayoutBuilderBundle\n\n\nWhat is a Layout\n\n\nA layout is a global template used to decorate page and content. A layout is composed of column, this columns are \nContentSet\n, And layout determine positionning style of this column inner the page.\n\n\nRequirement\n\n\nTo create layout, we highly recommend you to use LayoutBuilderBundle. To do so, add this to the composer.json of your project:\n\n\nrequire\n: {\n    \nphp\n: \n=5.4.0\n,\n    ...\n    \nbackbee/layout-builder-bundle\n: \n1.0.*@dev\n\n}\n\n\n\n\nAs last step you have to update your project dependencies by using composer:\n\n\ncomposer update\n\n\n\n\nCreate a Layout definition.\n\n\nLayoutBuilderBundle creates layouts based on YAML definitions. You have to put your definitions into the folder \n__PROJECT_ROOT_DIR__/repository/Layouts/definitions\n:\n\n\ncd mkdir repository/Layouts/Definitions\n\n\n\n\nAnd we can create your first layout definition, It will be composed by 2 columns, MainColumn and SidePane:\n\n\n\n\nrepository/Layouts/Definitions/LandingPage.yml\n\n\n\n\ntemplate: ~\nlabel: Landing Page Layout\ncolumns:\n  MainColumn:\n    mainZone: true\n    accept: ~\n    maxentry: ~\n    defaultClassContent: ~\n    inherited: false\n  SidePane:\n    mainZone: false\n    accept: ~\n    maxentry: ~\n    defaultClassContent: ~\n    inherited: true\n\n\n\n\nTemplate setting:\n\n\nThe template setting define what twig or phtml file you use to render the layout. By default, BackBee is able to automatically compute your layout template name by using the definition filename. In this case, \nLandingPage.twig\n or \nLandingPage.phtml\n. If you want to use a custom name you can specify it by using the key \ntemplate\n in your definition (default to \nnull\n which is equal to \n~\n). If you give a template name, you have to specify the extension too, Example:\n\n\ntemplate: landing_page.twig\n\n\n\n\nLabel setting:\n\n\nThis option allow you to change the label of your layout. It will be used to display the layout name in front.\n\n\nColumn setting:\n\n\nThis option define each column that the layout implement and there few options for each column.\n\n\nColumn -\n mainZone setting\n\n\nThis is to highlight your main column into your layout. MainColumn option permit to BackBee that create a direct link behind the page (and the URL) and the content contained into the main column. Each layout must have one unique main column.\n\n\nColumn -\n accept setting\n\n\nThis option permit to filter what type you can put into your column. In the case of the LandingPage layout we accept every type of content. But we can filter that and only accept for example an \nBackBee\\ClassContent\\Landing\\Contentainer\n:\n\n\naccept: ['Landing\\Container']\n\n\n\n\nColumn -\n maxentry setting\n\n\nThat option permit to add a maximum type of accepted content into the page. The default value and 0 is equal to unlimited.\n\n\nColumn -\n defaultClassContent setting\n\n\nThe default ClassContent setting permit to initialize the layout with the entity provided. Example like \naccept\n setting. To initialize the layout with the entity \nBackBee\\ClassContent\\Landing\\Contentainer\n, you have to write:\n\n\ndefaultClassContent: Landing\\Contentainer\n\n\n\n\nColumn -\n inherited setting\n\n\nThat setting determine the default behavior of your column, if you set at \ntrue\n this setting the column will inherit from the column in the same position in the parent page.\n\n\n\n\nrepository/Layouts/LandingPage.twig\n\n\n\n\n!doctype html\n\n\nhtml lang=\nen\n\n  \nhead\n\n    {{ this.partial('partials/head.twig')|raw }}\n  \n/head\n\n  \nbody\n\n    {{ this.bbtoolbar()|raw }}\n    \ndiv id=\nbb5-site-wrapper\n\n      \ndiv class=\nmain container\n\n        {{ this.container().first()|raw }}\n      \n/div\n\n      \ndiv class=\nside pane\n\n        {{ this.container().next()|raw }}\n      \n/div\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nIn this template there few think require:\n\n\n\n\nbbtoolbar\n permit to print the administration toolbar.\n\n\nid=\"bb5-site-wrapper\"\n is an identifier used by the toolbar to know where the Site content.\n\n\nthis.container().first()\n print the first column of your layout definition\n\n\nthis.container().next()\n print the next column of your layout definition, and if three column you continue to iterate the columns with this instruction.\n\n\n\n\nCreate a Layout template\n\n\nAs we see before with \ntemplate\n setting, the template must have the same filename as the definition (in the case of template is setted with the default option). The folder by default for your Layout is \nrepository/Layouts\n but folder work like\n\n\nSave the layout\n\n\nTo save the layout in database you have to use the commands line provided by \nLayoutBuilderBundle\n.\n\n\nCreate command\n\n\nCreation command don't override older layout and only create new template.\n\n\n./backbee layout::create\n\n\n\n\nLike this, the command will iterate all your layouts definitions and create this layout for each Site available.\nTo filter layout want create use the option \n--layout=\n and specify the layout you want create:\n\n\n./backbee layout::create --layout=LandingPage\n\n\n\n\nIf you have a multi site and you want add the layout to one specific site, you can use the option \n--site=\n and specify the label or domain name to this site\n\n\n./backbee layout::create --site=\nMy awesome Site\n\n\n\n\n\nAnd then, you can combine the 2 options.\n\n\nUpdate command\n\n\nUpdate command has the same options than create and do the same job, but this command override automatically Layout already save in database. Then use it carefully.\n\n\nRemove or add a column to a layout already used don't generate crash off this existent pages but the number off will not automatically upgrade to this older pages.\n\n\nRemove command\n\n\nIf you want delete an Layout, you can use this command. And this command accept to work only under some conditions.\n\n\nThe firsts condition is, the layout you have to remove, have to be unused.\nAnd you have to use all the previous options \n--layout\n and \n--site\n.", 
            "title": "Layout creation using LayoutBuilderBundle"
        }, 
        {
            "location": "/developer-documentation/cookbooks/layout_creation/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/layout_creation/#layout-creation-using-layoutbuilderbundle", 
            "text": "What is a Layout  A layout is a global template used to decorate page and content. A layout is composed of column, this columns are  ContentSet , And layout determine positionning style of this column inner the page.  Requirement  To create layout, we highly recommend you to use LayoutBuilderBundle. To do so, add this to the composer.json of your project:  require : {\n     php :  =5.4.0 ,\n    ...\n     backbee/layout-builder-bundle :  1.0.*@dev \n}  As last step you have to update your project dependencies by using composer:  composer update  Create a Layout definition.  LayoutBuilderBundle creates layouts based on YAML definitions. You have to put your definitions into the folder  __PROJECT_ROOT_DIR__/repository/Layouts/definitions :  cd mkdir repository/Layouts/Definitions  And we can create your first layout definition, It will be composed by 2 columns, MainColumn and SidePane:   repository/Layouts/Definitions/LandingPage.yml   template: ~\nlabel: Landing Page Layout\ncolumns:\n  MainColumn:\n    mainZone: true\n    accept: ~\n    maxentry: ~\n    defaultClassContent: ~\n    inherited: false\n  SidePane:\n    mainZone: false\n    accept: ~\n    maxentry: ~\n    defaultClassContent: ~\n    inherited: true  Template setting:  The template setting define what twig or phtml file you use to render the layout. By default, BackBee is able to automatically compute your layout template name by using the definition filename. In this case,  LandingPage.twig  or  LandingPage.phtml . If you want to use a custom name you can specify it by using the key  template  in your definition (default to  null  which is equal to  ~ ). If you give a template name, you have to specify the extension too, Example:  template: landing_page.twig  Label setting:  This option allow you to change the label of your layout. It will be used to display the layout name in front.  Column setting:  This option define each column that the layout implement and there few options for each column.  Column -  mainZone setting  This is to highlight your main column into your layout. MainColumn option permit to BackBee that create a direct link behind the page (and the URL) and the content contained into the main column. Each layout must have one unique main column.  Column -  accept setting  This option permit to filter what type you can put into your column. In the case of the LandingPage layout we accept every type of content. But we can filter that and only accept for example an  BackBee\\ClassContent\\Landing\\Contentainer :  accept: ['Landing\\Container']  Column -  maxentry setting  That option permit to add a maximum type of accepted content into the page. The default value and 0 is equal to unlimited.  Column -  defaultClassContent setting  The default ClassContent setting permit to initialize the layout with the entity provided. Example like  accept  setting. To initialize the layout with the entity  BackBee\\ClassContent\\Landing\\Contentainer , you have to write:  defaultClassContent: Landing\\Contentainer  Column -  inherited setting  That setting determine the default behavior of your column, if you set at  true  this setting the column will inherit from the column in the same position in the parent page.   repository/Layouts/LandingPage.twig   !doctype html  html lang= en \n   head \n    {{ this.partial('partials/head.twig')|raw }}\n   /head \n   body \n    {{ this.bbtoolbar()|raw }}\n     div id= bb5-site-wrapper \n       div class= main container \n        {{ this.container().first()|raw }}\n       /div \n       div class= side pane \n        {{ this.container().next()|raw }}\n       /div \n     /div \n   /body  /html   In this template there few think require:   bbtoolbar  permit to print the administration toolbar.  id=\"bb5-site-wrapper\"  is an identifier used by the toolbar to know where the Site content.  this.container().first()  print the first column of your layout definition  this.container().next()  print the next column of your layout definition, and if three column you continue to iterate the columns with this instruction.   Create a Layout template  As we see before with  template  setting, the template must have the same filename as the definition (in the case of template is setted with the default option). The folder by default for your Layout is  repository/Layouts  but folder work like  Save the layout  To save the layout in database you have to use the commands line provided by  LayoutBuilderBundle .  Create command  Creation command don't override older layout and only create new template.  ./backbee layout::create  Like this, the command will iterate all your layouts definitions and create this layout for each Site available.\nTo filter layout want create use the option  --layout=  and specify the layout you want create:  ./backbee layout::create --layout=LandingPage  If you have a multi site and you want add the layout to one specific site, you can use the option  --site=  and specify the label or domain name to this site  ./backbee layout::create --site= My awesome Site   And then, you can combine the 2 options.  Update command  Update command has the same options than create and do the same job, but this command override automatically Layout already save in database. Then use it carefully.  Remove or add a column to a layout already used don't generate crash off this existent pages but the number off will not automatically upgrade to this older pages.  Remove command  If you want delete an Layout, you can use this command. And this command accept to work only under some conditions.  The firsts condition is, the layout you have to remove, have to be unused.\nAnd you have to use all the previous options  --layout  and  --site .", 
            "title": "Layout creation using LayoutBuilderBundle"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_doctrine_commands_console/", 
            "text": "CookBooks\n\n\nImplement doctrine commands console\n\n\nConfiguration :\n\n\nTo use doctrine command console in your Backbee project:\n\n\n\n\nCreate this structure in your app root folder :\n\n\n\n\n/bin/doctrine\n/bin/config/cli-config.php\n/bin/src/bootstrap.php\n\n\n\n\nWhere \ndoctrine\n is a symbolic link to the doctrine vendor command:\n\n\nln -s ../vendor/bin/doctrine\n\n\n\n\nAnd \ncli-config.php\n contains the following code:\n\n\n?php\n\n// Doctrine CLI configuration file\nuse Doctrine\\ORM\\Tools\\Console\\ConsoleRunner;\n\nrequire_once __DIR__ . '/../src/bootstrap.php';\nreturn ConsoleRunner::createHelperSet($entityManager);\n\n\n\n\nAnd \nbootstrap.php\n contains the following code:\n\n\n?php\n\nuse Doctrine\\ORM\\Tools\\Setup;\n\nrequire_once \n../vendor/autoload.php\n;\n// Create a simple \ndefault\n Doctrine ORM configuration for XML Mapping\n$isDevMode = true;\n$config = Setup::createAnnotationMetadataConfiguration(array(__DIR__ . \n/src\n), $isDevMode);\n// or if you prefer yaml or annotations\n//$config = Setup::createXMLMetadataConfiguration(array(__DIR__.\n/config/xml\n), $isDevMode);\n//$config = Setup::createYAMLMetadataConfiguration(array(__DIR__.\n/config/yaml\n), $isDevMode);\n// database configuration parameters\n$conn = array(\n    'driver' =\n 'pdo_sqlite',\n    'path' =\n __DIR__ . '/db.sqlite',\n);\n// obtaining the entity manager\n$entityManager = \\Doctrine\\ORM\\EntityManager::create($conn, $config);\n\n\n\n\nYou should then be able from the \nbin\n folder to use the doctrine console command:\n\n\n#\n ./doctrine\n\n\n\n\n\n\nFor up-to-date \ncli-config.php\n and \nbootstrap.php\n files check the GIT repo @ https://github.com/doctrine/doctrine2-orm-tutorial.", 
            "title": "Implement Doctrine Commands Console"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_doctrine_commands_console/#cookbooks", 
            "text": "", 
            "title": "CookBooks"
        }, 
        {
            "location": "/developer-documentation/cookbooks/use_doctrine_commands_console/#implement-doctrine-commands-console", 
            "text": "Configuration :  To use doctrine command console in your Backbee project:   Create this structure in your app root folder :   /bin/doctrine\n/bin/config/cli-config.php\n/bin/src/bootstrap.php  Where  doctrine  is a symbolic link to the doctrine vendor command:  ln -s ../vendor/bin/doctrine  And  cli-config.php  contains the following code:  ?php\n\n// Doctrine CLI configuration file\nuse Doctrine\\ORM\\Tools\\Console\\ConsoleRunner;\n\nrequire_once __DIR__ . '/../src/bootstrap.php';\nreturn ConsoleRunner::createHelperSet($entityManager);  And  bootstrap.php  contains the following code:  ?php\n\nuse Doctrine\\ORM\\Tools\\Setup;\n\nrequire_once  ../vendor/autoload.php ;\n// Create a simple  default  Doctrine ORM configuration for XML Mapping\n$isDevMode = true;\n$config = Setup::createAnnotationMetadataConfiguration(array(__DIR__ .  /src ), $isDevMode);\n// or if you prefer yaml or annotations\n//$config = Setup::createXMLMetadataConfiguration(array(__DIR__. /config/xml ), $isDevMode);\n//$config = Setup::createYAMLMetadataConfiguration(array(__DIR__. /config/yaml ), $isDevMode);\n// database configuration parameters\n$conn = array(\n    'driver' =  'pdo_sqlite',\n    'path' =  __DIR__ . '/db.sqlite',\n);\n// obtaining the entity manager\n$entityManager = \\Doctrine\\ORM\\EntityManager::create($conn, $config);  You should then be able from the  bin  folder to use the doctrine console command:  #  ./doctrine   For up-to-date  cli-config.php  and  bootstrap.php  files check the GIT repo @ https://github.com/doctrine/doctrine2-orm-tutorial.", 
            "title": "Implement doctrine commands console"
        }, 
        {
            "location": "/developer-documentation/components/bundle/", 
            "text": "Components\n\n\nThe Bundle Component\n\n\nWhat is a bundle?\n\n\nIn BackBee, a bundle is like an BackBee's core application (\nBackBee\\BBApplication\n). It can bring its \nclass contents\n, \nconfigurations\n, \nlisteners\n, \nevents\n, \ntemplates\n, \ncontrollers\n, etc. It's surely even more flexible cause you can use bundle loader recipes to change the way things should be loaded. We will talk about this point later.\nWhile the core application contains many features to build up your website/application, a bundle \nmust\n contain only one main functionnality. For example, a ArticleDisqusBundle that brings article content and Disqus commenting feature \nmust not\n exist. A good solution is to split it into two distincts bundles:\n\n\n\n\nArticleBundle: could be a bundle that brings article classcontent and its views, maybe also some listeners to alter some behaviors.\n\n\nDisqusBundle: could simply be an implementation of Disqus API into BackBee.\n\n\n\n\nAlso, if one day you need the Disqus feature in another project that doesn't need article class content, this will result in embedding unused code. So keep it in mind: \none bundle = one feature\n.\n\n\nBundle folder structure and entry point\n\n\nA valid bundle should at least have a folder structure that contains an entry point and the \nConfig\n folder. Let's consider, for example, that our bundle is named NewsletterBundle.\n\n\nNEWSLETTER_BUNDLE_ROOT_FOLDER\n    |_ Config\n        |_ config.yml\n    |_ Newsletter.php\n\n\n\n\nThe entry point is essential for BackBee to know how to load your bundle. Note that the classname does not matter at all (no any standard to follow) but it must implement \nBackBee\\Bundle\\BundleInterface\n. We highly encourage you to extend \nBackBee\\Bundle\\AbstractBundle\n so you have only \n::start()\n and \n::stop()\n methods to implement before you are ready to go. You will find below a simple implementation of these two methods and we will explain to you how BackBee works and loads your bundles:\n\n\nnamespace BackBee\\Bundle\\NewsletterBundle;\n\nuse BackBee\\Bundle\\AbstractBundle;\n\nclass Newsletter extends AbstractBundle\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function start()\n    {\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function stop()\n    {\n        return $this;\n    }\n}\n\n\n\n\nExplanation: at the first time the bundle is accessed through application service container, its  \n::start()\n method will be invoked (so only once). And \n::stop()\n will be invoked in every started bundle when the event \nbbapplication.stop\nis dispatched.\n\n\nThe \nConfig/config.yml\n is also required. It will be parsed to get an instance of \nBackBee\\Config\\Config\n. Bellow is a list of bundle basic configuration parameters:\n\n\n# NEWSLETTER_BUNDLE_ROOT_FOLDER/Config/config.yml\nbundle:\n    name: NewsLetterBundle\n    description: This is a plugin that provide newsletters integration in BackBee\n    enable: true # define if the bundle should be load; default: true\n    config_per_site: false # allows you to have different configuration per site; default: false\n    category: [] # your bundle can belong to none, one or many categories; default: none\n    thumbnail: ~ # the thumbnail of your bundle; default: null\n\n\n\n\nNow we have seen what a bundle is and what is needed to create one. Let's learn how to register it to BackBee. You need to create \nbundles.yml\n into your project config folder (generally located at \nPROJECT_ROOT_DIR/repository/Config/\n):\n\n\n# PROJECT_ROOT_DIR/repository/Config/bundles.yml\nnl: BackBee\\Bundle\\NewsletterBundle\\Newsletter\ndemo: BackBee\\Bundle\\DemoBundle\\Demo\n\n\n\n\nThat's all! Pretty simple, right? One more thing, bundles are automatically loaded into the application service container. Your bundle identifier will always follow this pattern: \nbundle.__BUNDLE_NAME__\n. Note that the \n__BUNDLE_NAME__\n is the declared key of your bundle, so it's \nbundle.nl\n in this case (\nnl\n cause it's the key name of the bundle entry point in \nbundles.yml\n). You can also access to NewsletterBundle's config from the service container. Its service identifier follows this pattern: \nbundle.__BUNDLE_NAME__.config\n. So the NewsletterBundle config identifier is \nbundle.nl.config\n.\n\n\nWell, now you know the basics about BackBee's bundle. Let's move to the next level and learn more about how BackBee loads your bundles!\n\n\nHow the bundle loader works?\n\n\nDuring the execution of \nBackBee\\BBApplication::__construct\n a lot of things are done. Among them, we have the call to the bundle loader. First, BackBee loads its dependencies like its listeners, services, parameters (into dependency injection container), classcontents, etc. Then BackBee says \n\"Well bundle loader, it's time for you to do your job!\"\n.\nThe first task the bundle loader has to do is to get every declared bundle in  \nPROJECT_ROOT_DIR/repository/Config/bundles.yml\n file and load them one by one. Note that bundles are loaded is determined by declaration order in \nbundles.yml\n (in previous example, NewsletterBundle will be loaded first). The order is important cause the last loaded one will always win if there is a conflict about which template to use or which parameter value to use in service container. So \nbe careful about your bundle declaration order\n.\n\n\nFrom now on, consider that the current path (\n./\n) is \n__BUNDLE_BASE_DIR__\n. So \n./Config/\n is equal to \n__BUNDLE_BASE_DIR__/Config/\n.\n\n\nDefault expectations\n\n\nWe are now coming up to talk about bundle default structure expected by the loader:\n\n\n\n\nservices for dependency injection container can be declared in yaml or xml format and are expected to be found in \n./Config/services.[yml|xml]\n\n\nevents listeners are expected to be declared in \n./Config/events.yml\n\n\nroutes are expected to be declared in \n./Config/route.yml\n\n\nclasscontent folder is expected to be \n./ClassContent/\n\n\ntemplates are expected to be in \n./Templates/scripts/\n\n\nhelpers are expected to be in \n./Templates/helpers/\n\n\nresources are expected to be in \n./Resources/\n\n\n\n\nAs long as you follow theses standards you won't have anything to do to load your services, events, routes, classcontent, templates, helpers and resources.\n\n\nDefault bundle folder structure:\n\n\nBUNDLE_ROOT_FOLDER\n    |_ ClassContent/\n        |_ FakeContent.yml\n    |_ Config/\n        |_ config.yml\n        |_ events.yml\n        |_ route.yml\n        |_ services.yml\n    |_ Resources/\n        |_ css/\n            |_ fake.css\n    |_ Templates/\n        |_ helpers/\n            |_ fakeHelper.php\n        |_ scripts/\n            |_ FakeContent.html.twig\n    |_ EntryPoint.php\n\n\n\n\n\nUsing recipes to custom some loads\n\n\nAdmitting that we want to put our templates into \n./Resources/views/\n instead of \n./Templates/scripts/\n and our helpers into \n./Renderer/Helper/\n instead of \n./Templates/helpers/\n, how can we do that?\nIt's pretty simple if you use bundle loader recipes. They allow you use your custom recipe instead of the default one to load some part of your bundle. To load templates and helpers by yourself, simply add these line into \n./Config/config.yml\n:\n\n\n# ./Config/config.yml\nbundle:\n    enable: true\n    config_per_site: false\n    category: []\n    thumbnail: ~\n    bundle_loader_recipes:\n        helper: [BackBee\\Bundle\\FakeBundle\\EntryPoint, loadHelpers]\n        template: [BackBee\\Bundle\\FakeBundle\\EntryPoint, loadTemplates]\n\n\n\n\nBelow an example of how to implement these callbacks into \nBackBee\\Bundle\\FakeBundle\\EntryPoint\n:\n\n\nnamespace BackBee\\Bundle\\FakeBundle;\n\nuse BackBee\\BBApplication;\nuse BackBee\\Bundle\\AbstractBundle;\nuse BackBee\\Config\\Config;\n\nclass EntryPoint extends AbstractBundle\n{\n    public static function loadHelpers(BBApplication $app, Config $config)\n    {\n        $helperDir = __DIR__.DIRECTORY_SEPARATOR.'Renderer'.DIRECTORY_SEPARATOR.'Helper';\n        if (!is_dir($helperDir)) {\n            $app-\nerror(sprintf('Unable to load helpers directory (:%s).', $helperDir));\n        } else {\n            $app-\ngetRenderer()-\naddHelperDir($helperDir);\n        }\n    }\n\n    public static function loadTemplates(BBApplication $app, Config $config)\n    {\n        $viewsDir = __DIR__.DIRECTORY_SEPARATOR.'Resources'.DIRECTORY_SEPARATOR.'views';\n        if (!is_dir($viewsDir)) {\n            $app-\nerror(sprintf('Unable to load views directory (:%s).', $viewsDir));\n        } else {\n            $app-\ngetRenderer()-\naddScriptDir($viewsDir);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function start()\n    {\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function stop()\n    {\n        return $this;\n    }\n}\n\n\n\n\nWe just saw how to custom the loading of helpers and views. Below the complete list of recipes that the name bundle loader can interpret:\n\n\n\n\nclasscontent\n\n\ncustom\n: use this one if you want to run custom loader without altering default behavior\n\n\nevent\n\n\nhelper\n\n\nnamespace\n\n\nresource\n\n\nroute\n\n\nservice\n\n\ntemplate", 
            "title": "Bundle"
        }, 
        {
            "location": "/developer-documentation/components/bundle/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/bundle/#the-bundle-component", 
            "text": "", 
            "title": "The Bundle Component"
        }, 
        {
            "location": "/developer-documentation/components/bundle/#what-is-a-bundle", 
            "text": "In BackBee, a bundle is like an BackBee's core application ( BackBee\\BBApplication ). It can bring its  class contents ,  configurations ,  listeners ,  events ,  templates ,  controllers , etc. It's surely even more flexible cause you can use bundle loader recipes to change the way things should be loaded. We will talk about this point later.\nWhile the core application contains many features to build up your website/application, a bundle  must  contain only one main functionnality. For example, a ArticleDisqusBundle that brings article content and Disqus commenting feature  must not  exist. A good solution is to split it into two distincts bundles:   ArticleBundle: could be a bundle that brings article classcontent and its views, maybe also some listeners to alter some behaviors.  DisqusBundle: could simply be an implementation of Disqus API into BackBee.   Also, if one day you need the Disqus feature in another project that doesn't need article class content, this will result in embedding unused code. So keep it in mind:  one bundle = one feature .", 
            "title": "What is a bundle?"
        }, 
        {
            "location": "/developer-documentation/components/bundle/#bundle-folder-structure-and-entry-point", 
            "text": "A valid bundle should at least have a folder structure that contains an entry point and the  Config  folder. Let's consider, for example, that our bundle is named NewsletterBundle.  NEWSLETTER_BUNDLE_ROOT_FOLDER\n    |_ Config\n        |_ config.yml\n    |_ Newsletter.php  The entry point is essential for BackBee to know how to load your bundle. Note that the classname does not matter at all (no any standard to follow) but it must implement  BackBee\\Bundle\\BundleInterface . We highly encourage you to extend  BackBee\\Bundle\\AbstractBundle  so you have only  ::start()  and  ::stop()  methods to implement before you are ready to go. You will find below a simple implementation of these two methods and we will explain to you how BackBee works and loads your bundles:  namespace BackBee\\Bundle\\NewsletterBundle;\n\nuse BackBee\\Bundle\\AbstractBundle;\n\nclass Newsletter extends AbstractBundle\n{\n    /**\n     * {@inheritdoc}\n     */\n    public function start()\n    {\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function stop()\n    {\n        return $this;\n    }\n}  Explanation: at the first time the bundle is accessed through application service container, its   ::start()  method will be invoked (so only once). And  ::stop()  will be invoked in every started bundle when the event  bbapplication.stop is dispatched.  The  Config/config.yml  is also required. It will be parsed to get an instance of  BackBee\\Config\\Config . Bellow is a list of bundle basic configuration parameters:  # NEWSLETTER_BUNDLE_ROOT_FOLDER/Config/config.yml\nbundle:\n    name: NewsLetterBundle\n    description: This is a plugin that provide newsletters integration in BackBee\n    enable: true # define if the bundle should be load; default: true\n    config_per_site: false # allows you to have different configuration per site; default: false\n    category: [] # your bundle can belong to none, one or many categories; default: none\n    thumbnail: ~ # the thumbnail of your bundle; default: null  Now we have seen what a bundle is and what is needed to create one. Let's learn how to register it to BackBee. You need to create  bundles.yml  into your project config folder (generally located at  PROJECT_ROOT_DIR/repository/Config/ ):  # PROJECT_ROOT_DIR/repository/Config/bundles.yml\nnl: BackBee\\Bundle\\NewsletterBundle\\Newsletter\ndemo: BackBee\\Bundle\\DemoBundle\\Demo  That's all! Pretty simple, right? One more thing, bundles are automatically loaded into the application service container. Your bundle identifier will always follow this pattern:  bundle.__BUNDLE_NAME__ . Note that the  __BUNDLE_NAME__  is the declared key of your bundle, so it's  bundle.nl  in this case ( nl  cause it's the key name of the bundle entry point in  bundles.yml ). You can also access to NewsletterBundle's config from the service container. Its service identifier follows this pattern:  bundle.__BUNDLE_NAME__.config . So the NewsletterBundle config identifier is  bundle.nl.config .  Well, now you know the basics about BackBee's bundle. Let's move to the next level and learn more about how BackBee loads your bundles!", 
            "title": "Bundle folder structure and entry point"
        }, 
        {
            "location": "/developer-documentation/components/bundle/#how-the-bundle-loader-works", 
            "text": "During the execution of  BackBee\\BBApplication::__construct  a lot of things are done. Among them, we have the call to the bundle loader. First, BackBee loads its dependencies like its listeners, services, parameters (into dependency injection container), classcontents, etc. Then BackBee says  \"Well bundle loader, it's time for you to do your job!\" .\nThe first task the bundle loader has to do is to get every declared bundle in   PROJECT_ROOT_DIR/repository/Config/bundles.yml  file and load them one by one. Note that bundles are loaded is determined by declaration order in  bundles.yml  (in previous example, NewsletterBundle will be loaded first). The order is important cause the last loaded one will always win if there is a conflict about which template to use or which parameter value to use in service container. So  be careful about your bundle declaration order .  From now on, consider that the current path ( ./ ) is  __BUNDLE_BASE_DIR__ . So  ./Config/  is equal to  __BUNDLE_BASE_DIR__/Config/ .  Default expectations  We are now coming up to talk about bundle default structure expected by the loader:   services for dependency injection container can be declared in yaml or xml format and are expected to be found in  ./Config/services.[yml|xml]  events listeners are expected to be declared in  ./Config/events.yml  routes are expected to be declared in  ./Config/route.yml  classcontent folder is expected to be  ./ClassContent/  templates are expected to be in  ./Templates/scripts/  helpers are expected to be in  ./Templates/helpers/  resources are expected to be in  ./Resources/   As long as you follow theses standards you won't have anything to do to load your services, events, routes, classcontent, templates, helpers and resources.  Default bundle folder structure:  BUNDLE_ROOT_FOLDER\n    |_ ClassContent/\n        |_ FakeContent.yml\n    |_ Config/\n        |_ config.yml\n        |_ events.yml\n        |_ route.yml\n        |_ services.yml\n    |_ Resources/\n        |_ css/\n            |_ fake.css\n    |_ Templates/\n        |_ helpers/\n            |_ fakeHelper.php\n        |_ scripts/\n            |_ FakeContent.html.twig\n    |_ EntryPoint.php  Using recipes to custom some loads  Admitting that we want to put our templates into  ./Resources/views/  instead of  ./Templates/scripts/  and our helpers into  ./Renderer/Helper/  instead of  ./Templates/helpers/ , how can we do that?\nIt's pretty simple if you use bundle loader recipes. They allow you use your custom recipe instead of the default one to load some part of your bundle. To load templates and helpers by yourself, simply add these line into  ./Config/config.yml :  # ./Config/config.yml\nbundle:\n    enable: true\n    config_per_site: false\n    category: []\n    thumbnail: ~\n    bundle_loader_recipes:\n        helper: [BackBee\\Bundle\\FakeBundle\\EntryPoint, loadHelpers]\n        template: [BackBee\\Bundle\\FakeBundle\\EntryPoint, loadTemplates]  Below an example of how to implement these callbacks into  BackBee\\Bundle\\FakeBundle\\EntryPoint :  namespace BackBee\\Bundle\\FakeBundle;\n\nuse BackBee\\BBApplication;\nuse BackBee\\Bundle\\AbstractBundle;\nuse BackBee\\Config\\Config;\n\nclass EntryPoint extends AbstractBundle\n{\n    public static function loadHelpers(BBApplication $app, Config $config)\n    {\n        $helperDir = __DIR__.DIRECTORY_SEPARATOR.'Renderer'.DIRECTORY_SEPARATOR.'Helper';\n        if (!is_dir($helperDir)) {\n            $app- error(sprintf('Unable to load helpers directory (:%s).', $helperDir));\n        } else {\n            $app- getRenderer()- addHelperDir($helperDir);\n        }\n    }\n\n    public static function loadTemplates(BBApplication $app, Config $config)\n    {\n        $viewsDir = __DIR__.DIRECTORY_SEPARATOR.'Resources'.DIRECTORY_SEPARATOR.'views';\n        if (!is_dir($viewsDir)) {\n            $app- error(sprintf('Unable to load views directory (:%s).', $viewsDir));\n        } else {\n            $app- getRenderer()- addScriptDir($viewsDir);\n        }\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function start()\n    {\n        return $this;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function stop()\n    {\n        return $this;\n    }\n}  We just saw how to custom the loading of helpers and views. Below the complete list of recipes that the name bundle loader can interpret:   classcontent  custom : use this one if you want to run custom loader without altering default behavior  event  helper  namespace  resource  route  service  template", 
            "title": "How the bundle loader works?"
        }, 
        {
            "location": "/developer-documentation/components/cache/", 
            "text": "Components\n\n\nThe Cache Component\n\n\nThe Cache component provides many adapters to the most used and cache systems for validating/invalidating the cache.\n\n\nCache Adapters\n\n\n\n\nAPC Adapter: Uses \nAPC\n cache if available\n\n\nDAO Adapter: Uses database cache system\n\n\nFileAdapter: Uses file system\n\n\nMemcache Adapter: Uses \nmemcache\n if available and set up\n\n\nMemcached Adapter: Uses \nmemcached\n if available and set up\n\n\n\n\nThere is also a special one, used when cache is not activated: the \nNoCache\n adapter.\n\n\nYou can create your own adapters implementing the \nCacheInterface\n interface:\n\n\n?php\n/*\n * Copyright (c) 2011-2015 Lp digital system\n *\n * This file is part of BackBee.\n *\n * BackBee is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * BackBee is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with BackBee. If not, see \nhttp://www.gnu.org/licenses/\n.\n *\n * @author Charles Rouillon \ncharles.rouillon@lp-digital.fr\n\n */\nnamespace BackBee\\Cache;\nuse Psr\\Log\\LoggerInterface;\nuse BackBee\\Cache\\Exception\\CacheException;\n/**\n * Abstract class for cache adapters.\n *\n * @category    BackBee\n *\n * @copyright   Lp digital system\n * @author      Micka\u00ebl Andrieu \nmickael.andrieu@lp-digital.fr\n\n */\ninterface CacheInterface\n{\n    /**\n     * Returns the available cache for the given id if found returns false else.\n     *\n     * @param string    $id          Cache id\n     * @param boolean   $bypassCheck Allow to find cache without test it before\n     * @param \\DateTime $expire      Optionnal, the expiration time (now by default)\n     *\n     * @return string|false\n     */\n    public function load($id, $bypassCheck, \\DateTime $expire);\n    /**\n     * Tests if a cache is available or not (for the given id).\n     *\n     * @param string $id Cache id\n     *\n     * @return int|false the last modified timestamp of the available cache record (0 infinite expiration date)\n     */\n    public function test($id);\n    /**\n     * Saves some string datas into a cache record.\n     *\n     * @param string $id       Cache id\n     * @param string $data     Datas to cache\n     * @param int    $lifetime Optional, the specific lifetime for this record\n     *                         (by default null, infinite lifetime)\n     * @param string $tag      Optional, an associated tag to the data stored\n     *\n     * @return boolean true if cache is stored false otherwise\n     */\n    public function save($id, $data, $lifetime, $tag);\n    /**\n     * Removes a cache record.\n     *\n     * @param string $id Cache id\n     *\n     * @return boolean true if cache is removed false otherwise\n     */\n    public function remove($id);\n    /**\n     * Clears all cache records.\n     *\n     * @return boolean true if cache is cleared false otherwise\n     */\n    public function clear();\n    /**\n     * Sets the cache logger.\n     *\n     * @param \\Psr\\Log\\LoggerInterface $logger\n     *\n     * @return \\BackBee\\Cache\\CacheAdapterInterface\n     */\n    public function setLogger(LoggerInterface $logger);\n    /**\n     * Gets the cache logger.\n     *\n     * @return \\Psr\\Log\\LoggerInterface $logger\n     */\n    public function getLogger();\n    /**\n     * Returns the cache context.\n     *\n     * @return string|null\n     */\n    public function getContext();\n    /**\n     * Sets the cache context.\n     *\n     * @param string $context\n     *\n     * @return \\BackBee\\Cache\\CacheAdapterInterface\n     */\n    public function setContext($context);\n    /**\n     * Logs a message on provided level if a logger is defined.\n     *\n     * @param string $level   The log level\n     * @param string $message The message to log\n     * @param array  $context The logging context\n     */\n    public function log($level, $message, array $context);\n    /**\n     * Returns the expiration timestamp.\n     *\n     * @param int $lifetime\n     *\n     * @return int\n     */\n    public function getExpireTime($lifetime);\n    /**\n     * Control the lifetime against min and max lifetime if provided.\n     *\n     * @param int $lifetime\n     *\n     * @return int\n     */\n    public function getControledLifetime($lifetime);\n}\n\n\n\n\nYou can also extend the \nAbstractCache\n class provided by the Cache component.\n\n\nCache validating/invalidating\n\n\nThanks to the \nBackBee\\Cache\\CacheValidator\n class, you can use the Symfony Validator component to validate or invalidate your cache. Let's see an use case.\n\n\nThe CacheListener occurs at prerender at postrender and flush with contents. Before going deeper into each of these methods, we need to test various parameters of the application and the application. So we can define a validation group called ' cache_status '. This group contains two validators :\n\n\n\n\nApplicationCoreValidator check:\n\n\nthat the user is not a BBUser;\n\n\nthat the application is not in debug mode\n\n\nthe application has started and that is not a customer SAPI\n\n\n\n\n\n\nRequestValidator check:\n\n\nthat the request method is GET because we do not want to hide the POST or PUT requests for example.\n\n\n\n\n\n\n\n\nThe execution of prerender methods postrender and flush a content CacheListener is conditional that respond positively CacheValidator :\n\n\n?php\nclass CacheListener\n{\n    public function onPreRenderContent(BackBee\\Event\\Event $event)\n    {\n        $cache_validator = $event-\ngetApplication()\n            -\ngetContainer()\n            -\nget('cache.validator');\n\n        if (!$cache_validator-\nisValid('cache_status', $event-\ngetTarget())) { // the second parameter of isValid() is optional\n            return;\n        }\n\n        // execute your pre-render tasks\n    }\n}\n\n\n\n\nYou can set as many validation group as you want and create as validator as you like provided they implement all the \nBackBee\\Cache\\Validator\\ValidatorInterface\n interface and are declared in a services.yml (that of the repository or any of your bundles) with \ncache.validator\n tag. \n\n\nThis last point allows the CacheValidator load them automatically so you do add them manually with CacheValidator \naddValidator::method()\n.\n\n\nCache key generator\n\n\nThe BackBee Cache component provide a centralized cache key generator: the class \nBackBee\\Cache\\CacheIdentifierGenerator\n.\n\n\nThis service (accessible from the container application with id \ncache.identifier_generator\n) generates a new cache id as the generator group that you provide as a parameter.\n\n\nThese groups consist of one or more appenders.\n\n\nYou can define as generator groups as you like and arbitrarily select the number of appender in each of its groups. The only requirement is that a generator must necessarily implement the \nBackBee\\Cache\\IdentifierAppender\\IdentifierAppenderInterface interface\n.\n\n\nThey can be automatically loaded into the CacheIdentifierGenerator if you declare them as a repository of service or one of your bundles .\n\n\nNote that each generator must have the tag \ncache.identifier.appender\n.", 
            "title": "Cache"
        }, 
        {
            "location": "/developer-documentation/components/cache/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/cache/#the-cache-component", 
            "text": "The Cache component provides many adapters to the most used and cache systems for validating/invalidating the cache.", 
            "title": "The Cache Component"
        }, 
        {
            "location": "/developer-documentation/components/cache/#cache-adapters", 
            "text": "APC Adapter: Uses  APC  cache if available  DAO Adapter: Uses database cache system  FileAdapter: Uses file system  Memcache Adapter: Uses  memcache  if available and set up  Memcached Adapter: Uses  memcached  if available and set up   There is also a special one, used when cache is not activated: the  NoCache  adapter.  You can create your own adapters implementing the  CacheInterface  interface:  ?php\n/*\n * Copyright (c) 2011-2015 Lp digital system\n *\n * This file is part of BackBee.\n *\n * BackBee is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * BackBee is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with BackBee. If not, see  http://www.gnu.org/licenses/ .\n *\n * @author Charles Rouillon  charles.rouillon@lp-digital.fr \n */\nnamespace BackBee\\Cache;\nuse Psr\\Log\\LoggerInterface;\nuse BackBee\\Cache\\Exception\\CacheException;\n/**\n * Abstract class for cache adapters.\n *\n * @category    BackBee\n *\n * @copyright   Lp digital system\n * @author      Micka\u00ebl Andrieu  mickael.andrieu@lp-digital.fr \n */\ninterface CacheInterface\n{\n    /**\n     * Returns the available cache for the given id if found returns false else.\n     *\n     * @param string    $id          Cache id\n     * @param boolean   $bypassCheck Allow to find cache without test it before\n     * @param \\DateTime $expire      Optionnal, the expiration time (now by default)\n     *\n     * @return string|false\n     */\n    public function load($id, $bypassCheck, \\DateTime $expire);\n    /**\n     * Tests if a cache is available or not (for the given id).\n     *\n     * @param string $id Cache id\n     *\n     * @return int|false the last modified timestamp of the available cache record (0 infinite expiration date)\n     */\n    public function test($id);\n    /**\n     * Saves some string datas into a cache record.\n     *\n     * @param string $id       Cache id\n     * @param string $data     Datas to cache\n     * @param int    $lifetime Optional, the specific lifetime for this record\n     *                         (by default null, infinite lifetime)\n     * @param string $tag      Optional, an associated tag to the data stored\n     *\n     * @return boolean true if cache is stored false otherwise\n     */\n    public function save($id, $data, $lifetime, $tag);\n    /**\n     * Removes a cache record.\n     *\n     * @param string $id Cache id\n     *\n     * @return boolean true if cache is removed false otherwise\n     */\n    public function remove($id);\n    /**\n     * Clears all cache records.\n     *\n     * @return boolean true if cache is cleared false otherwise\n     */\n    public function clear();\n    /**\n     * Sets the cache logger.\n     *\n     * @param \\Psr\\Log\\LoggerInterface $logger\n     *\n     * @return \\BackBee\\Cache\\CacheAdapterInterface\n     */\n    public function setLogger(LoggerInterface $logger);\n    /**\n     * Gets the cache logger.\n     *\n     * @return \\Psr\\Log\\LoggerInterface $logger\n     */\n    public function getLogger();\n    /**\n     * Returns the cache context.\n     *\n     * @return string|null\n     */\n    public function getContext();\n    /**\n     * Sets the cache context.\n     *\n     * @param string $context\n     *\n     * @return \\BackBee\\Cache\\CacheAdapterInterface\n     */\n    public function setContext($context);\n    /**\n     * Logs a message on provided level if a logger is defined.\n     *\n     * @param string $level   The log level\n     * @param string $message The message to log\n     * @param array  $context The logging context\n     */\n    public function log($level, $message, array $context);\n    /**\n     * Returns the expiration timestamp.\n     *\n     * @param int $lifetime\n     *\n     * @return int\n     */\n    public function getExpireTime($lifetime);\n    /**\n     * Control the lifetime against min and max lifetime if provided.\n     *\n     * @param int $lifetime\n     *\n     * @return int\n     */\n    public function getControledLifetime($lifetime);\n}  You can also extend the  AbstractCache  class provided by the Cache component.", 
            "title": "Cache Adapters"
        }, 
        {
            "location": "/developer-documentation/components/cache/#cache-validatinginvalidating", 
            "text": "Thanks to the  BackBee\\Cache\\CacheValidator  class, you can use the Symfony Validator component to validate or invalidate your cache. Let's see an use case.  The CacheListener occurs at prerender at postrender and flush with contents. Before going deeper into each of these methods, we need to test various parameters of the application and the application. So we can define a validation group called ' cache_status '. This group contains two validators :   ApplicationCoreValidator check:  that the user is not a BBUser;  that the application is not in debug mode  the application has started and that is not a customer SAPI    RequestValidator check:  that the request method is GET because we do not want to hide the POST or PUT requests for example.     The execution of prerender methods postrender and flush a content CacheListener is conditional that respond positively CacheValidator :  ?php\nclass CacheListener\n{\n    public function onPreRenderContent(BackBee\\Event\\Event $event)\n    {\n        $cache_validator = $event- getApplication()\n            - getContainer()\n            - get('cache.validator');\n\n        if (!$cache_validator- isValid('cache_status', $event- getTarget())) { // the second parameter of isValid() is optional\n            return;\n        }\n\n        // execute your pre-render tasks\n    }\n}  You can set as many validation group as you want and create as validator as you like provided they implement all the  BackBee\\Cache\\Validator\\ValidatorInterface  interface and are declared in a services.yml (that of the repository or any of your bundles) with  cache.validator  tag.   This last point allows the CacheValidator load them automatically so you do add them manually with CacheValidator  addValidator::method() .", 
            "title": "Cache validating/invalidating"
        }, 
        {
            "location": "/developer-documentation/components/cache/#cache-key-generator", 
            "text": "The BackBee Cache component provide a centralized cache key generator: the class  BackBee\\Cache\\CacheIdentifierGenerator .  This service (accessible from the container application with id  cache.identifier_generator ) generates a new cache id as the generator group that you provide as a parameter.  These groups consist of one or more appenders.  You can define as generator groups as you like and arbitrarily select the number of appender in each of its groups. The only requirement is that a generator must necessarily implement the  BackBee\\Cache\\IdentifierAppender\\IdentifierAppenderInterface interface .  They can be automatically loaded into the CacheIdentifierGenerator if you declare them as a repository of service or one of your bundles .  Note that each generator must have the tag  cache.identifier.appender .", 
            "title": "Cache key generator"
        }, 
        {
            "location": "/developer-documentation/components/classcontent/", 
            "text": "Components\n\n\nThe ClassContent Component\n\n\nWhat is a ClassContent?\n\n\nClassContents are at the heart of BackBee, every piece of content you will find in BackBee is a ClassContent. It defines your site and how you contribute to it.\nClassContents can be extended, listened, versioned and they all have in common that they implement \nBackBee\\Renderer\\RenderableInterface\n.\nIn general a ClassContent is defined in YAML, it can be implemented in PHP too but the YAML notation because it's easier, quicker and scalable compared to PHP.\n\n\nHow it works\n\n\nThe definition of a ClassContent follows \nPHPCR recommendations\n and every flexible content is a combination of primary content types.\n\n\nPHPCR definition:\n\n\n\n\nThe PHP Content Repository is an adaption of the Java Content Repository (JCR) standard, an open API specification defined in JSR-283.\nThe API defines how to handle hierarchical semi-structured data in a consistent way.\n\n\nThe typical use case is content management systems. PHPCR combines the best out of document-oriented databases (weak structured data) and of XML databases (hierarchical trees). On top of that, it adds useful features like searching, versioning, access control and locking on top of it.\n\n\n\n\nClassContent is composed of it's definition class and it's templates. The storage of ClassContent is automated and is done int the content table, BackBee uses the Doctrine discriminator system to store contributed entities.\n\n\nA ClassContent definition is generally declared in a YAML file and is composed of three major parts \nproperties\n, \nelements\n and \nparameters\n\n\nNaming Convention\n\n\nClassContent is declared in a \nClassContent\n folder and its final namespace depends on the folder where you declare a new entity. All ClassContent have common root namespaces which is \nBackBee\\ClassContent\n. If you create a definition file in a folder named \nArticle\n and this file is named \nParagraph.yml\n the complete namespace for this content is\nBackBee\\ClassContent\\Article\\Paragraph\n.\n\n\nRespect the PSR naming convention. PSR specification is:\n\n\n\n\nNamespaces and classes MUST follow an \"autoloading\" PSR: [\nPSR-0\n, \nPSR-4\n].\nThis means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name.\nClass names MUST be declared in StudlyCaps.\n\n\n\n\nEven if ClassContent are in most cases YML files, they are designed to become PHP Class, then you must declare names in StudlyCaps.\n\n\nPrimary ClassContent types\n\n\nThe primary ClassContents types are the most basic types in BackBee. They are the base of every other Content.\n\n\nBackBee provides 5 primary ClassContent types:\n\n\n\n\nContentSet: a container of content, they are iterable and countable.\n\n\nElement\\Text: a simple text input\n\n\nElement\\File : an attached file\n\n\nElement\\Link : a URL link\n\n\nElement\\Keyword : a keyword association\n\n\n\n\nNative ClassContent types\n\n\nIn addition to the primary types BackBee provides four Natives ClassContents and theses contents are extensions of primary contents:\n\n\n\n\nElement\\Attachment , an attachment content, extending Element\\File\n\n\nElement\\Date, a date input, extending Element\\Text\n\n\nElement\\Image , an image content, extending Element\\File\n\n\nElement\\Select , a select input, extending Element\\Text\n\n\n\n\nCreate a ClassContent definition\n\n\nIn most cases extending native and primary ClassContent is unnecessary. You simply create a new ClassContent type that uses some primary and native types.\n\n\nExample for an article :\n\n\nOur article will have one title, one picture and one body. You translate this textual definition in ClassContent as followed:\n\n\n\n\nArticle.yml\n\n\n\n\nArticle:\n  properties:\n    name: Article\n    description: \nAn is compose of one title, one picture and one body\n\n    category: [article]\n  elements:\n    title:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Title\n      default:\n        value: Your title here...\n      maxentry: 1\n    body:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Body\n      default:\n        value: Your abstract here...\n      maxentry: 1\n    picture:\n      type: BackBee\\ClassContent\\Element\\Image\n\n\n\n\nFocus on properties section:\n\n\nname: Article\n\n\n\n\nThe property \nname\n is for humans and can be composed of multiple words like \"Basic Article\"\n\n\ndescription: \nAn is compose of one title, one picture and one body\n\n\n\n\n\nThe property \ndescription\n goes against human reading and provides a description of what to do with your ClassContent and/or what it  is compose of.\n\n\ncategory: [article]\n\n\n\n\nThe property \ncategory\n helps you to categorize your ClassContent and if content isn't categorized it can't be edited online, you musn't forget to assign a category to each content. In addition a ClassContent can be categorized and visually hidden in the toolbar if you use this notation:\n\n\ncategory: [!article]\n\n\n\n\nFocus on elements section:\n\n\ntitle:\n  type: BackBee\\ClassContent\\Element\\Text\n  label: Title\n  default:\n    value: Your title here...\n  maxentry: 1\n\n\n\n\ntitle:\n\n\n\n\nThis will be the identifier property and the way you access code like this  \n{{ this.render(title)|raw }}\n in template file\n\n\ntype: BackBee\\ClassContent\\Element\\Text\n\n\n\n\nType is the definition of your content. Here the title is defined by the primary ClassContent type \nElement\\Text\n\n\nlabel: Title\n\n\n\n\nThe property label is for humans and can be composed of multiple words like \"Basic Article\" it appears under a contribution form.\n\n\ndefault:\n  value: \nYour title here...\n\n\n\n\n\nThe default section allows you to define how just initialized ClassContent appears. Here the default value of the title is \"Your title here...\"\n\n\nmaxentry: 1\n\n\n\n\nThis property determine how many entries of this property the Class Content can accept.\n\n\nClassContent templates\n\n\nWhen BackBee tries to render your class content, it searches a template corresponding to it's name. In the previous case the searched template was \nArticle.twig\n or \nArticle.phtml\n\n\nIf BackBee can't find the template it will retrieve the template of each element and render the elements separately. If you provide only a definition, BackBee is able to render it.\n\n\n\n\nArticle.twig\n\n\n\n\narticle {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype=\nhttp://schema.org/Article\n\n  \nh1 {{ this.bbcontent(title)|raw }} itemprop=\nheadline\n\n    {{ title.value|raw }}\n  \n/h1\n\n  \ndiv itemtype=\nhttp://schema.org/ImageObject\n itemprop=\nprimaryImageOfPage\n\n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n  \n/div\n\n  {{ this.render(body)|raw }}\n\n/article\n\n\n\n\n\ntemplate and render mode\n\n\nThe render mode has the same function as the template but it can be considered as an alternative template. In general, render mode is automatically called by a block extending \nContentSet\n, by default when you render it use the name of this block to require an alternative rendering. But you can also define the rendering using \nparameters\n or in the template directly when you use the function render \nthis.render(Article, 'renderMode')\n.\n\n\nIn the next example we will put our article into an ArticleList and then we alternate the rendering of the article creating a file named \nArticle.ArticleList.twig\n and this template will be automatically used by BackBee.\n\n\n\n\nArticle.ArticleList.twig\n\n\n\n\narticle {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype=\nhttp://schema.org/Article\n\n  \nh2 {{ this.bbcontent(title)|raw }} itemprop=\nheadline\n\n    {{ title.value|raw }}\n  \n/h2\n\n  \ndiv itemtype=\nhttp://schema.org/ImageObject\n itemprop=\nprimaryImageOfPage\n\n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n  \n/div\n\n\n/article\n\n\n\n\n\nBackBee can't find the render mode \nArticle.ArticleList.twig\n it will try to render \nArticle.twig\n and it if doesn't find this template it will render each element with its default rendering mode.\n\n\nContentSet\n\n\nContentSets are particular ClassContents instead of a classic ClassContent, a ContentSet doesn't have elements section and represents only a collection of other ClassContent. But you can customize a ClassContents trough its \nparameters\n section.\n\n\nRelatedContainer:\n  extends: \\BackBee\\ClassContent\\ContentSet\n  properties:\n    name: Linked article container\n    description: \nA block that display linked article\n\n    category: [Article]\n  parameters:\n    rendermode: related\n    accept: [BackBee\\ClassContent\\Article\\Article]\n\n\n\n\n\n\nAs you can see a ContentSet has extended \n\\BackBee\\ClassContent\\ContentSet\n\n\n\n\nFocus on parameters section:\n\n\nrendermode: related\n\n\n\n\nRender mode allows you to override the default behavior of BackBee by redefining the render mode named on sub content. We have seen that by default BackBee tries to find a render mode by using the name of the ContentSet then by default \nRenderer\n search a file named \nArticle.RelatedContainer.twig\n. By using the \nrendermode\n setting you will find \nArticle.related.twig\n file.\n\n\naccept: [BackBee\\ClassContent\\Article\\Article]\n\n\n\n\nThe accept parameter prefilters the type of ClassContent you can add into your ContentSet.\n\n\nContentSet templates\n\n\nContentSet template is rendered exactly at same way as other ClassContent. The only difference is that you have to use a loop to render the collection.\n\n\n\n\nRelatedContainer.twig\n\n\n\n\n\ndiv {{ this.bbcontent(null, {'class': 'col-md-4'})|raw }}\n\n    {% for article in this.getObject().getData() %}\n        {{ this.render(article)|raw }}\n    {% endfor %}\n\n/div\n\n\n\n\n\nTo access the ContentSet collection you have to use this way \nthis.getObject().getData()\n\n\nThe \"Autoblock\"\n\n\nAn Autoblock isn't a primitive or native ClassContent and is a mix between these two types.\nAn Autoblock is a fully automated Content, its collection isn't contributable and automatically creates a list of ClassContent. This list is generated by the configuration of the Autoblock.\n\n\nBy default BackBee doesn't provide \"Autoblock\" but there is one provided in the standard edition.\n\n\nAn Autoblock has to be highly configurable and all the configuration is created in the \nparameters\n section. An Autoblock has to implement a listener to automatically generate its collection. You can find more information in the Parameters section.\n\n\nOverride, Extends, listen and add Trait to your ClassContent\n\n\nOverriding a ClassContent\n\n\nAs with the Configuration system, you can override a ClassContent definition.\n\n\nThe priority system tries to find the definition and template in this order :\n- \nrepository/{context}/ClassContent\n into your current context\n- \nrepository/ClassContent\n into your default context\n- \n{bundle}/ClassContent\n into your bundles ClassContent folder\n- \nClassContent\n into ClassContent BackBee component\n\n\nIf you create a file with the same name as an existing content but a different folder has the priority, this content will be modified and take the value in the created file. This work also for the template, but have to be replaced \nClassContent\n folder with \nTemplates/scripts\n\n\nExtends a ClassContent\n\n\nTo extend an other ClassContent, you just have to use \nextends\n keyword like in the example of the ContentSet.\n\n\nThere are many advantages to extending an other class content. First you do not have to rewrite properties and elements.\n\n\nThe second advantage concerns rendering and listeners, BackBee will run through the parent classes to find templates and listener.\n\n\nListen a ClassContent\n\n\nAdd an event listener to a class content is pretty easy and you will find more information in the \nEvent Listener component\n section.\n\n\nTo summarize each ClassContent has 4 attached events:\n- \nclasscontent.include\n: on the first instantiation of the class content,\n- \nclasscontent.prerender\n: before the content is rendered,\n- \nclasscontent.render\n: during the content is rendered,\n- \nclasscontent.postrender\n: after the content is rendered.\n\n\nPlus all of the events dispatched by Doctrine:\n- \nclasscontent.preflush\n: before the content entity is flushed,\n- \nclasscontent.onflush\n: during the content entity is flushed,\n- \nclasscontent.postflush\n: after tthe content entity is flushed,\n- \nclasscontent.postload\n: after the content entity was loaded,\n- \nclasscontent.preremove\n: before the content entity is removed,\n- \nclasscontent.postremove\n: after the content entity is removed,\n- \nclasscontent.prepersist\n: before a new content entity is inserted,\n- \nclasscontent.preupdate\n: before a content entity is updated,\n- \nclasscontent.postupdate\n: after a content entity is updated.\n\n\nAdd a Trait  to a ClassContent\n\n\nTrait lets go add behaviors to a ClassContent. By default BackBee doesn't provide trait, but like Autoblocks, some traits are available in the standard edition. If you don't know what is a trait, check the official \nPHP documentation\n.\n\n\nClassContent Parameters\n\n\nParameters allow you to configure contents. ClassContent parameters are usually used in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.\n\n\nParameters are built from the block's YAML like\n\n\nBlockDemo:\n    properties:\n        name: Block demo\n        description: \nBlock for demonstration purposes\n\n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']\n\n\n\n\n\nUse parameters\n\n\nIf ClassContent Parameters are not validated by user the content parameters are overridden by revision parameters.\n\nOnly the value of the parameter is saved.\n\n\nTo get default parameters:\n\n\n?php\n$params = $content-\ngetDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get all parameters:\n\n\n?php\n\n$params = $content-\ngetAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' =\n\n *      array (size=3)\n *        'label' =\n string 'My text' (length=7)\n *        'type' =\n string 'text' (length=4)\n *        'value' =\n string '' (length=0)\n *    'myselect' =\n\n *      array (size=4)\n *        'label' =\n string 'My select' (length=9)\n *        'type' =\n string 'select' (length=6)\n *        'options' =\n\n *          array (size=2)\n *            'foo' =\n string 'Foo' (length=3)\n *            'bar' =\n string 'Bar' (length=3)\n *        'value' =\n\n *          array (size=1)\n *            0 =\n string 'foo' (length=3)\n */\n\n\n\n\nTo get one parameter:\n\n\n?php\n$param = $content-\ngetParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =\n string 'My text' (length=7)\n *    'type' =\n string 'text' (length=4)\n *    'value' =\n string '' (length=0)\n */\n\n\n\n\nTo get the value of the parameter:\n\n\n?php\n$paramValue = $content-\ngetParamValue('mytext');\n\n// That returns the new value string '' (length=0)\n\n\n\n\nTo set a value, you need to set up the same type you declare in the YAML file as the value:\n\n\n?php\n$content-\nsetParam('mytext', 'foo');\n$param = $content-\ngetParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)\n\n\n\n\nProperties reference\n\n\n\n\nname\n\n\ndescription\n\n\ncategory\n\n\nindexation\n\n\nlabelized-by\n\n\niconized-by\n\n\n\n\n\n\nname\n\n\nThe name of the content\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nname\n\n\nString\n\n\nThe name of the content\n\n\nEmpty string\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    name: Article\n\n\n\n\n?php\n$name = $content-\ngetProperty('name'); // \nArticle\n\n\n\n\n\n\n\ndescription\n\n\nThe description of the content\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\ndescription\n\n\nString\n\n\nThe description of the content\n\n\nEmpty string\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    description: \nAn article contains a title, an author, an abstract, a primary image and a body\n\n\n\n\n\n?php\n$name = $content-\ngetProperty('description'); // \nAn article contains a title, an author, an abstract, a primary image and a body\n\n\n\n\n\n\n\ncategory\n\n\nUsed to categorize the content.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\ncategory\n\n\nArray\n\n\nAn array content categories\n\n\nEmpty array\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    category: [Article, News]\n\n\n\n\n\n\nindexation\n\n\nList of references to chained elements or parameters to be indexed on content entity flush.\n\n\nEach of the listed elements or parameters can be associated to a callback function.\n\n\nA reference to a parameter will be prefixed by \n@\n.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nindexation\n\n\nArray\n\n\nAn array of chained elements or parameters\n\n\nEmpty array\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    indexation: [[title-\nvalue, strip_tags], [@isNews]]\n\n\n\n\n\n\nlabelized-by\n\n\nA reference to a chained element that will be used to labelize the content.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nlabelized-by\n\n\nString\n\n\nA reference to a chained element\n\n\nEmpty string\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    labelized-by: title-\nvalue\n\n\n\n\n\n\niconized-by\n\n\nA reference to a chained element or parameter that will be used to get an icon for the content.\n\n\nThe URI of the icon will be resolved according to the \nrouting\n component rules.\n\n\nA reference to a parameter will be prefixed by \n@\n.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\niconized-by\n\n\nString\n\n\nA reference to a chained element or parameter\n\n\nEmpty string\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nproperties:\n    iconized-by: image-\nimage-\npath\n\n\n\n\nParameters reference\n\n\n\n\ncheckbox\n\n\ndatetimepicker\n\n\nhidden\n\n\nlinkSelector\n\n\nmediaSelector\n\n\nnodeSelector\n\n\npassword\n\n\nradio\n\n\nselect\n\n\ntext\n\n\ntextarea\n\n\n\n\nAll parameters have default options:\n\n\nDefault options\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nlabel\n\n\nString\n\n\nLabel is displayed above the field\n\n\nEmpty\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nMixed\n\n\nThis field must be set and allows to describe the  parameter's type\n\n\nNone\n\n\nYes\n\n\n\n\n\n\ntype\n\n\nString\n\n\nKey of one of available parameters\n\n\nNone\n\n\nYes\n\n\n\n\n\n\n\n\n\n\nCheckbox\n\n\nLike HTML checkbox attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay checkbox inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected checkboxes\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mycheckbox'); // sarray('foo')\n\n\n\n\n\n\nDatetime picker\n\n\nText element with a datetimepicker\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nNumber\n\n\nIt is an timestamp value\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mydatetimepicker'); // 1435573740\n\n\n\n\n\n\nHidden\n\n\nLike HTML hidden attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myhidden'); // foo\n\n\n\n\n\n\nLink selector\n\n\nLink selector allows you to choose a link from one of your website pages or an external link.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url / title / pageUid / target\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmax_entry\n\n\nInteger\n\n\nAllow to restrict number of link\n\n\nnull\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one link\n$param = $content-\ngetParamValue('mylinkselector');\n// array('url' =\n '/foo', 'title' =\n 'Foo', 'pageUid' =\n 'anPageUid', 'target' =\n '_self')\n\n\n\n\n Page tree \n:\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.\n\n\n External link \n :\nIn this case, note the pageUid attribute is (obviously) null.\n\n\n\n\nMedia selector\n\n\nMedia selector allows you to choose a list of media in the media library.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains folder_uid / image / media_id / title /type / uid\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmax_entry\n\n\nInteger\n\n\nAllow to restrict number of media\n\n\nnull\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []\n\n\n\n\n?php\n# Example with select one media\n$param = $content-\ngetParamValue('mymediaselector');\n// array(array('folder_uid' =\n 'anFolderUid', 'image' =\n 'imageUrl', 'media_id' =\n '1', 'title' =\n '_Foo', 'type' =\n 'Media/Image', 'uid' =\n 'anUid'))\n\n\n\n\n\n\nNode selector\n\n\nNode selector allows you to choose a page from tree\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nJson\n\n\nObject which contains url  pageUid / title\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmax_entry\n\n\nInteger\n\n\nAllow to restrict number of node\n\n\nnull\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []\n\n\n\n\n# Example of node selection\n$param = $content-\ngetParamValue('mynodeselector');\n# array('pageUid' =\n 'anPageUid', 'title' =\n 'Foo')\n\n\n\n\nWe recommend retrieving the title from the page entity instead of the attributed title because the title can change.\n\n\n\n\nPassword\n\n\nLike HTML password attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nRadio\n\n\nLike HTML radio attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\ninline\n\n\nBoolean\n\n\nDisplay radio inline\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); // array('foo')\n\n\n\n\n\n\nSelect\n\n\nLike HTML select attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\noptions\n\n\nArray\n\n\nList of options (key/value)\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nList of selected radio\n\n\nEmpty array\n\n\nYes\n\n\n\n\n\n\nmultiple\n\n\nBoolean\n\n\nAllows multiple selection\n\n\nfalse\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true\n\n\n\n\n?php\n$param = $content-\ngetParamValue('myradio'); //array('foo')\n\n\n\n\n\n\nText\n\n\nLike HTML text attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytext:\n        type: 'text'\n        value: 'foo'\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mypassword'); // foo\n\n\n\n\n\n\nTextarea\n\n\nLike HTML textearea attribute\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nString\n\n\nThe default text\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\nrows\n\n\nString\n\n\nthe rows html attribute\n\n\n5\n\n\nNo\n\n\n\n\n\n\n\n\nExample\n:\n\n\nparameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10\n\n\n\n\n?php\n$param = $content-\ngetParamValue('mytextearea'); // BackBee\n\n\n\n\n\n\nSpecial parameters\n\n\nRendermode\n\n\nRendermode parameters automatically list rendermodes of content and use them directly.\n\n\n\n\n\n\n\n\n\n\nType\n\n\nDescription\n\n\nDefault\n\n\nMandatory\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nArray\n\n\nSelected rendermode\n\n\nEmpty\n\n\nYes\n\n\n\n\n\n\n\n\nparameters:\n    rendermode:\n        type: 'select'\n        value: []\n\n\n\n\nThe key must be 'rendermode'", 
            "title": "ClassContent"
        }, 
        {
            "location": "/developer-documentation/components/classcontent/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/classcontent/#the-classcontent-component", 
            "text": "What is a ClassContent?  ClassContents are at the heart of BackBee, every piece of content you will find in BackBee is a ClassContent. It defines your site and how you contribute to it.\nClassContents can be extended, listened, versioned and they all have in common that they implement  BackBee\\Renderer\\RenderableInterface .\nIn general a ClassContent is defined in YAML, it can be implemented in PHP too but the YAML notation because it's easier, quicker and scalable compared to PHP.  How it works  The definition of a ClassContent follows  PHPCR recommendations  and every flexible content is a combination of primary content types.  PHPCR definition:   The PHP Content Repository is an adaption of the Java Content Repository (JCR) standard, an open API specification defined in JSR-283.\nThe API defines how to handle hierarchical semi-structured data in a consistent way.  The typical use case is content management systems. PHPCR combines the best out of document-oriented databases (weak structured data) and of XML databases (hierarchical trees). On top of that, it adds useful features like searching, versioning, access control and locking on top of it.   ClassContent is composed of it's definition class and it's templates. The storage of ClassContent is automated and is done int the content table, BackBee uses the Doctrine discriminator system to store contributed entities.  A ClassContent definition is generally declared in a YAML file and is composed of three major parts  properties ,  elements  and  parameters  Naming Convention  ClassContent is declared in a  ClassContent  folder and its final namespace depends on the folder where you declare a new entity. All ClassContent have common root namespaces which is  BackBee\\ClassContent . If you create a definition file in a folder named  Article  and this file is named  Paragraph.yml  the complete namespace for this content is BackBee\\ClassContent\\Article\\Paragraph .  Respect the PSR naming convention. PSR specification is:   Namespaces and classes MUST follow an \"autoloading\" PSR: [ PSR-0 ,  PSR-4 ].\nThis means each class is in a file by itself, and is in a namespace of at least one level: a top-level vendor name.\nClass names MUST be declared in StudlyCaps.   Even if ClassContent are in most cases YML files, they are designed to become PHP Class, then you must declare names in StudlyCaps.  Primary ClassContent types  The primary ClassContents types are the most basic types in BackBee. They are the base of every other Content.  BackBee provides 5 primary ClassContent types:   ContentSet: a container of content, they are iterable and countable.  Element\\Text: a simple text input  Element\\File : an attached file  Element\\Link : a URL link  Element\\Keyword : a keyword association   Native ClassContent types  In addition to the primary types BackBee provides four Natives ClassContents and theses contents are extensions of primary contents:   Element\\Attachment , an attachment content, extending Element\\File  Element\\Date, a date input, extending Element\\Text  Element\\Image , an image content, extending Element\\File  Element\\Select , a select input, extending Element\\Text   Create a ClassContent definition  In most cases extending native and primary ClassContent is unnecessary. You simply create a new ClassContent type that uses some primary and native types.  Example for an article :  Our article will have one title, one picture and one body. You translate this textual definition in ClassContent as followed:   Article.yml   Article:\n  properties:\n    name: Article\n    description:  An is compose of one title, one picture and one body \n    category: [article]\n  elements:\n    title:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Title\n      default:\n        value: Your title here...\n      maxentry: 1\n    body:\n      type: BackBee\\ClassContent\\Element\\Text\n      label: Body\n      default:\n        value: Your abstract here...\n      maxentry: 1\n    picture:\n      type: BackBee\\ClassContent\\Element\\Image  Focus on properties section:  name: Article  The property  name  is for humans and can be composed of multiple words like \"Basic Article\"  description:  An is compose of one title, one picture and one body   The property  description  goes against human reading and provides a description of what to do with your ClassContent and/or what it  is compose of.  category: [article]  The property  category  helps you to categorize your ClassContent and if content isn't categorized it can't be edited online, you musn't forget to assign a category to each content. In addition a ClassContent can be categorized and visually hidden in the toolbar if you use this notation:  category: [!article]  Focus on elements section:  title:\n  type: BackBee\\ClassContent\\Element\\Text\n  label: Title\n  default:\n    value: Your title here...\n  maxentry: 1  title:  This will be the identifier property and the way you access code like this   {{ this.render(title)|raw }}  in template file  type: BackBee\\ClassContent\\Element\\Text  Type is the definition of your content. Here the title is defined by the primary ClassContent type  Element\\Text  label: Title  The property label is for humans and can be composed of multiple words like \"Basic Article\" it appears under a contribution form.  default:\n  value:  Your title here...   The default section allows you to define how just initialized ClassContent appears. Here the default value of the title is \"Your title here...\"  maxentry: 1  This property determine how many entries of this property the Class Content can accept.  ClassContent templates  When BackBee tries to render your class content, it searches a template corresponding to it's name. In the previous case the searched template was  Article.twig  or  Article.phtml  If BackBee can't find the template it will retrieve the template of each element and render the elements separately. If you provide only a definition, BackBee is able to render it.   Article.twig   article {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype= http://schema.org/Article \n   h1 {{ this.bbcontent(title)|raw }} itemprop= headline \n    {{ title.value|raw }}\n   /h1 \n   div itemtype= http://schema.org/ImageObject  itemprop= primaryImageOfPage \n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n   /div \n  {{ this.render(body)|raw }} /article   template and render mode  The render mode has the same function as the template but it can be considered as an alternative template. In general, render mode is automatically called by a block extending  ContentSet , by default when you render it use the name of this block to require an alternative rendering. But you can also define the rendering using  parameters  or in the template directly when you use the function render  this.render(Article, 'renderMode') .  In the next example we will put our article into an ArticleList and then we alternate the rendering of the article creating a file named  Article.ArticleList.twig  and this template will be automatically used by BackBee.   Article.ArticleList.twig   article {{ this.bbcontent(null, null, {class: 'article box-wrapper'})|raw }} itemscope itemtype= http://schema.org/Article \n   h2 {{ this.bbcontent(title)|raw }} itemprop= headline \n    {{ title.value|raw }}\n   /h2 \n   div itemtype= http://schema.org/ImageObject  itemprop= primaryImageOfPage \n    {{ this.render(image, null, {'class': 'figure block-fullwidth'})|raw }}\n   /div  /article   BackBee can't find the render mode  Article.ArticleList.twig  it will try to render  Article.twig  and it if doesn't find this template it will render each element with its default rendering mode.  ContentSet  ContentSets are particular ClassContents instead of a classic ClassContent, a ContentSet doesn't have elements section and represents only a collection of other ClassContent. But you can customize a ClassContents trough its  parameters  section.  RelatedContainer:\n  extends: \\BackBee\\ClassContent\\ContentSet\n  properties:\n    name: Linked article container\n    description:  A block that display linked article \n    category: [Article]\n  parameters:\n    rendermode: related\n    accept: [BackBee\\ClassContent\\Article\\Article]   As you can see a ContentSet has extended  \\BackBee\\ClassContent\\ContentSet   Focus on parameters section:  rendermode: related  Render mode allows you to override the default behavior of BackBee by redefining the render mode named on sub content. We have seen that by default BackBee tries to find a render mode by using the name of the ContentSet then by default  Renderer  search a file named  Article.RelatedContainer.twig . By using the  rendermode  setting you will find  Article.related.twig  file.  accept: [BackBee\\ClassContent\\Article\\Article]  The accept parameter prefilters the type of ClassContent you can add into your ContentSet.  ContentSet templates  ContentSet template is rendered exactly at same way as other ClassContent. The only difference is that you have to use a loop to render the collection.   RelatedContainer.twig   div {{ this.bbcontent(null, {'class': 'col-md-4'})|raw }} \n    {% for article in this.getObject().getData() %}\n        {{ this.render(article)|raw }}\n    {% endfor %} /div   To access the ContentSet collection you have to use this way  this.getObject().getData()  The \"Autoblock\"  An Autoblock isn't a primitive or native ClassContent and is a mix between these two types.\nAn Autoblock is a fully automated Content, its collection isn't contributable and automatically creates a list of ClassContent. This list is generated by the configuration of the Autoblock.  By default BackBee doesn't provide \"Autoblock\" but there is one provided in the standard edition.  An Autoblock has to be highly configurable and all the configuration is created in the  parameters  section. An Autoblock has to implement a listener to automatically generate its collection. You can find more information in the Parameters section.  Override, Extends, listen and add Trait to your ClassContent  Overriding a ClassContent  As with the Configuration system, you can override a ClassContent definition.  The priority system tries to find the definition and template in this order :\n-  repository/{context}/ClassContent  into your current context\n-  repository/ClassContent  into your default context\n-  {bundle}/ClassContent  into your bundles ClassContent folder\n-  ClassContent  into ClassContent BackBee component  If you create a file with the same name as an existing content but a different folder has the priority, this content will be modified and take the value in the created file. This work also for the template, but have to be replaced  ClassContent  folder with  Templates/scripts  Extends a ClassContent  To extend an other ClassContent, you just have to use  extends  keyword like in the example of the ContentSet.  There are many advantages to extending an other class content. First you do not have to rewrite properties and elements.  The second advantage concerns rendering and listeners, BackBee will run through the parent classes to find templates and listener.  Listen a ClassContent  Add an event listener to a class content is pretty easy and you will find more information in the  Event Listener component  section.  To summarize each ClassContent has 4 attached events:\n-  classcontent.include : on the first instantiation of the class content,\n-  classcontent.prerender : before the content is rendered,\n-  classcontent.render : during the content is rendered,\n-  classcontent.postrender : after the content is rendered.  Plus all of the events dispatched by Doctrine:\n-  classcontent.preflush : before the content entity is flushed,\n-  classcontent.onflush : during the content entity is flushed,\n-  classcontent.postflush : after tthe content entity is flushed,\n-  classcontent.postload : after the content entity was loaded,\n-  classcontent.preremove : before the content entity is removed,\n-  classcontent.postremove : after the content entity is removed,\n-  classcontent.prepersist : before a new content entity is inserted,\n-  classcontent.preupdate : before a content entity is updated,\n-  classcontent.postupdate : after a content entity is updated.  Add a Trait  to a ClassContent  Trait lets go add behaviors to a ClassContent. By default BackBee doesn't provide trait, but like Autoblocks, some traits are available in the standard edition. If you don't know what is a trait, check the official  PHP documentation .  ClassContent Parameters  Parameters allow you to configure contents. ClassContent parameters are usually used in the listener but can be used everywhere. ClassContent parameters are contributed in back office by the user with the gearing button of Block.  Parameters are built from the block's YAML like  BlockDemo:\n    properties:\n        name: Block demo\n        description:  Block for demonstration purposes \n        category: [Demo]\n    elements:\n        text:\n            type: BackBee\\ClassContent\\Element\\Text\n    parameters:\n        mytext:\n            label: 'My text'\n            type: 'text'\n            value: ''\n        myselect:\n            label: 'My select'\n            type: 'select'\n            options:\n                'foo': 'Foo'\n                'bar': 'Bar'\n            value: ['foo']  Use parameters  If ClassContent Parameters are not validated by user the content parameters are overridden by revision parameters. Only the value of the parameter is saved.  To get default parameters:  ?php\n$params = $content- getDefaultParams();\n\n/** That returns all parameters with definitions and default values:\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)string 'yolo' (length=4)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get all parameters:  ?php\n\n$params = $content- getAllParams();\n\n/** That returns all parameters with definitions and new values\n *  array (size=2)\n *    'mytext' = \n *      array (size=3)\n *        'label' =  string 'My text' (length=7)\n *        'type' =  string 'text' (length=4)\n *        'value' =  string '' (length=0)\n *    'myselect' = \n *      array (size=4)\n *        'label' =  string 'My select' (length=9)\n *        'type' =  string 'select' (length=6)\n *        'options' = \n *          array (size=2)\n *            'foo' =  string 'Foo' (length=3)\n *            'bar' =  string 'Bar' (length=3)\n *        'value' = \n *          array (size=1)\n *            0 =  string 'foo' (length=3)\n */  To get one parameter:  ?php\n$param = $content- getParam('mytext');\n\n/** That returns the definition and new value\n *  array (size=3)\n *    'label' =  string 'My text' (length=7)\n *    'type' =  string 'text' (length=4)\n *    'value' =  string '' (length=0)\n */  To get the value of the parameter:  ?php\n$paramValue = $content- getParamValue('mytext');\n\n// That returns the new value string '' (length=0)  To set a value, you need to set up the same type you declare in the YAML file as the value:  ?php\n$content- setParam('mytext', 'foo');\n$param = $content- getParamValue('mytext')\n\n// That returns a new value set  string 'foo' (length=3)", 
            "title": "The ClassContent Component"
        }, 
        {
            "location": "/developer-documentation/components/classcontent/#properties-reference", 
            "text": "name  description  category  indexation  labelized-by  iconized-by    name  The name of the content      Type  Description  Default  Mandatory      name  String  The name of the content  Empty string  No     Example :  properties:\n    name: Article  ?php\n$name = $content- getProperty('name'); //  Article    description  The description of the content      Type  Description  Default  Mandatory      description  String  The description of the content  Empty string  No     Example :  properties:\n    description:  An article contains a title, an author, an abstract, a primary image and a body   ?php\n$name = $content- getProperty('description'); //  An article contains a title, an author, an abstract, a primary image and a body    category  Used to categorize the content.      Type  Description  Default  Mandatory      category  Array  An array content categories  Empty array  No     Example :  properties:\n    category: [Article, News]   indexation  List of references to chained elements or parameters to be indexed on content entity flush.  Each of the listed elements or parameters can be associated to a callback function.  A reference to a parameter will be prefixed by  @ .      Type  Description  Default  Mandatory      indexation  Array  An array of chained elements or parameters  Empty array  No     Example :  properties:\n    indexation: [[title- value, strip_tags], [@isNews]]   labelized-by  A reference to a chained element that will be used to labelize the content.      Type  Description  Default  Mandatory      labelized-by  String  A reference to a chained element  Empty string  No     Example :  properties:\n    labelized-by: title- value   iconized-by  A reference to a chained element or parameter that will be used to get an icon for the content.  The URI of the icon will be resolved according to the  routing  component rules.  A reference to a parameter will be prefixed by  @ .      Type  Description  Default  Mandatory      iconized-by  String  A reference to a chained element or parameter  Empty string  No     Example :  properties:\n    iconized-by: image- image- path", 
            "title": "Properties reference"
        }, 
        {
            "location": "/developer-documentation/components/classcontent/#parameters-reference", 
            "text": "checkbox  datetimepicker  hidden  linkSelector  mediaSelector  nodeSelector  password  radio  select  text  textarea   All parameters have default options:  Default options      Type  Description  Default  Mandatory      label  String  Label is displayed above the field  Empty  No    value  Mixed  This field must be set and allows to describe the  parameter's type  None  Yes    type  String  Key of one of available parameters  None  Yes      Checkbox  Like HTML checkbox attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display checkbox inline  false  No    value  Array  List of selected checkboxes  Empty array  Yes     Example :  parameters:\n    mycheckbox:\n        type: 'checkbox'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('mycheckbox'); // sarray('foo')   Datetime picker  Text element with a datetimepicker      Type  Description  Default  Mandatory      value  Number  It is an timestamp value  Empty  Yes     Example :  parameters:\n    mydatetimepicker:\n        type: 'datetimepicker'\n        value: 1435573740  ?php\n$param = $content- getParamValue('mydatetimepicker'); // 1435573740   Hidden  Like HTML hidden attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    myhidden:\n        type: 'hidden'\n        value: 'foo'  ?php\n$param = $content- getParamValue('myhidden'); // foo   Link selector  Link selector allows you to choose a link from one of your website pages or an external link.      Type  Description  Default  Mandatory      value  Json  Object which contains url / title / pageUid / target  Empty array  Yes    max_entry  Integer  Allow to restrict number of link  null  No     Example :  parameters:\n    mylinkselector:\n        type: 'linkSelector'\n        value: []  ?php\n# Example with select one link\n$param = $content- getParamValue('mylinkselector');\n// array('url' =  '/foo', 'title' =  'Foo', 'pageUid' =  'anPageUid', 'target' =  '_self')   Page tree  :\nWe recommend to retrieve the url from the page entity instead of the url attribute because the url can change.   External link   :\nIn this case, note the pageUid attribute is (obviously) null.   Media selector  Media selector allows you to choose a list of media in the media library.      Type  Description  Default  Mandatory      value  Json  Object which contains folder_uid / image / media_id / title /type / uid  Empty array  Yes    max_entry  Integer  Allow to restrict number of media  null  No     Example :  parameters:\n    mymediaselector:\n        type: 'mediaSelector'\n        value: []  ?php\n# Example with select one media\n$param = $content- getParamValue('mymediaselector');\n// array(array('folder_uid' =  'anFolderUid', 'image' =  'imageUrl', 'media_id' =  '1', 'title' =  '_Foo', 'type' =  'Media/Image', 'uid' =  'anUid'))   Node selector  Node selector allows you to choose a page from tree      Type  Description  Default  Mandatory      value  Json  Object which contains url  pageUid / title  Empty array  Yes    max_entry  Integer  Allow to restrict number of node  null  No     Example :  parameters:\n    mynodeselector:\n        type: 'nodeSelector'\n        value: []  # Example of node selection\n$param = $content- getParamValue('mynodeselector');\n# array('pageUid' =  'anPageUid', 'title' =  'Foo')  We recommend retrieving the title from the page entity instead of the attributed title because the title can change.   Password  Like HTML password attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mypassword:\n        type: 'password'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Radio  Like HTML radio attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    inline  Boolean  Display radio inline  false  No    value  Array  List of selected radio  Empty array  Yes     Example :  parameters:\n    myradio:\n        type: 'radio'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        inline: true  ?php\n$param = $content- getParamValue('myradio'); // array('foo')   Select  Like HTML select attribute      Type  Description  Default  Mandatory      options  Array  List of options (key/value)  Empty array  Yes    value  Array  List of selected radio  Empty array  Yes    multiple  Boolean  Allows multiple selection  false  No     Example :  parameters:\n    mypassword:\n        type: 'select'\n        options:\n            'foo': 'Foo'\n            'bar': 'Bar'\n        value: ['foo']\n        multiple: true  ?php\n$param = $content- getParamValue('myradio'); //array('foo')   Text  Like HTML text attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes     Example :  parameters:\n    mytext:\n        type: 'text'\n        value: 'foo'  ?php\n$param = $content- getParamValue('mypassword'); // foo   Textarea  Like HTML textearea attribute      Type  Description  Default  Mandatory      value  String  The default text  Empty  Yes    rows  String  the rows html attribute  5  No     Example :  parameters:\n    mytextearea:\n        type: 'textarea'\n        value: 'BackBee'\n        rows: 10  ?php\n$param = $content- getParamValue('mytextearea'); // BackBee   Special parameters  Rendermode  Rendermode parameters automatically list rendermodes of content and use them directly.      Type  Description  Default  Mandatory      value  Array  Selected rendermode  Empty  Yes     parameters:\n    rendermode:\n        type: 'select'\n        value: []  The key must be 'rendermode'", 
            "title": "Parameters reference"
        }, 
        {
            "location": "/developer-documentation/components/config/", 
            "text": "Components\n\n\nThe Config Component\n\n\nThis component is used in BackBee to set parameters from YAML files into the Container.\n\n\nHow the Config component works ?\n\n\nThe BackBee Config Component provides a \nConfig\n object able to:\n\n\n\n\nParse YAML files from a directory;\n\n\nPersist this configuration in file or in database;\n\n\nSet this configuration in \nBackBee Container\n;\n\n\nSave and load configuration from \nBackBee Cache\n;\n\n\n\n\n?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?\n\n\n\n\n\nThis component is not related and not compatible with Symfony Config component.\n\n\nYAML parsing, filtering and extending\n\n\nThe BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look at the \nSymfony YAML format documentation\n.\n\n\nMoreover, BackBee Config component allows you to ignore some files.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?\n\n\n\n\n\nThis way, the ignored files won't be parsed.\n\n\nThanks to the \nBackBee environments\n, you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when you are in a \"testing\" environment.\n\n\nYou can set the environment this way:\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config-\nsetEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific \nenvironment files\n:\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?\n\n\n\n\n\nThis is simple and powerful, you can be very specific about the configuration you want to use.\nConfiguration keys and parameters are merged recursively, starting from the base directory to the environnement directory.\nThanks to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.\n\n\n?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config-\nextend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/\n$directory\n\n         * If a key is declared in \n$directory\n configuration files, the configuration is overriden\n         */\n    }\n}\n\n?\n\n\n\n\n\nConfiguration persisting\n\n\nThe BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the \nBackBee\\Config\\PersistorInterface\n.\n\n\nFor now, two persistors are provided in BackBee CMS:\n\n\n\n\nthe \nFile\n Persistor allows you to write and override the main configuration file (config.yml)\n\n\nthe \nRegistry\n Persistor is a simple database Key/Value system\n\n\n\n\nIf we take a look at the BackBee CMS configuration:\n\n\nconfig:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]\n\n\n\n\n\n\nsave_in_registry\n is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.\n\n\npersistor\n is the list of activated persistors. BackBee will loop into each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.\n\n\n\n\nConfiguration caching\n\n\nThe BackBee Config Component is fully compatible with BackBee Cache component.\n\n\nWhen you create your Config object, you can pass an instance of \nBackBee\\Cache\\AbstractCache\n as a second argument.\nThis way, in a non-debug mode (fourth argument, \nfalse\n by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Config"
        }, 
        {
            "location": "/developer-documentation/components/config/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/config/#the-config-component", 
            "text": "This component is used in BackBee to set parameters from YAML files into the Container.", 
            "title": "The Config Component"
        }, 
        {
            "location": "/developer-documentation/components/config/#how-the-config-component-works", 
            "text": "The BackBee Config Component provides a  Config  object able to:   Parse YAML files from a directory;  Persist this configuration in file or in database;  Set this configuration in  BackBee Container ;  Save and load configuration from  BackBee Cache ;   ?php\n\nuse BackBee\\Cache\\AbstractCache;\nuse BackBee\\Config\\Config;\nuse BackBee\\DependencyInjection\\Container;\nuse BackBee\\DependencyInjection\\DispatchTagEventInterface;\nuse BackBee\\DependencyInjection\\Dumper\\DumpableServiceInterface;\n\nclass Config implements DispatchTagEventInterface, DumpableServiceInterface\n{\n    public function __construct(\n        $basedir,\n        AbstractCache $cache = null,\n        Container $container = null,\n        $debug = false,\n        array $yml_to_ignore = []\n    ){/*..*/}\n}\n\n?   This component is not related and not compatible with Symfony Config component.", 
            "title": "How the Config component works ?"
        }, 
        {
            "location": "/developer-documentation/components/config/#yaml-parsing-filtering-and-extending", 
            "text": "The BackBee Config Component can take a valid directory as argument, and merge the configuration according to the data set\nin this YAML files. If you don't know YAML, you can take a look at the  Symfony YAML format documentation .  Moreover, BackBee Config component allows you to ignore some files.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function returnConfiguration(array $filesToIgnore)\n    {\n        return new Config(self::DIRECTORY, null, null, false, $filesToIgnore);\n    }\n}\n\n?   This way, the ignored files won't be parsed.  Thanks to the  BackBee environments , you can also extend and improve your default configuration.\nFor instance, let's say you want to add a specific configuration when you are in a \"testing\" environment.  You can set the environment this way:  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function TestingConfiguration()\n    {\n        $config = new Config('/repository/Config', null, null, false, []);\n\n        return $config- setEnvironment('testing');\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config\n         * /repository/Config/testing\n         * and we are also able to parse specific  environment files :\n         * /repository/Config/foo.testing.yml\n         */\n    }\n}\n\n?   This is simple and powerful, you can be very specific about the configuration you want to use.\nConfiguration keys and parameters are merged recursively, starting from the base directory to the environnement directory.\nThanks to the \"On cascade system\", you can also add a new directory to allow an override of the current configuration.  ?php\n\nuse BackBee\\Config\\Config;\n\nclass Foo\n{\n    const DIRECTORY = '/my-valid/path';\n\n    public function overrideTestingConfiguration(Config $config, $directory)\n    {\n        return $config- extend($directory);\n\n        /**\n         * Now the object is able to parse YAML files from theses directories:\n         * /repository/Config/ $directory \n         * If a key is declared in  $directory  configuration files, the configuration is overriden\n         */\n    }\n}\n\n?", 
            "title": "YAML parsing, filtering and extending"
        }, 
        {
            "location": "/developer-documentation/components/config/#configuration-persisting", 
            "text": "The BackBee Config Component can persist configurations in file or in database, you can also create your own \"persistors\"\nthanks to the  BackBee\\Config\\PersistorInterface .  For now, two persistors are provided in BackBee CMS:   the  File  Persistor allows you to write and override the main configuration file (config.yml)  the  Registry  Persistor is a simple database Key/Value system   If we take a look at the BackBee CMS configuration:  config:\n    save_in_registry: true # default value: true\n    persistor: [BackBee\\Config\\Persistor\\File, BackBee\\Config\\Persistor\\Registry]   save_in_registry  is a particular option: if true, this means BackBee will try to look for an overidden configuration\n  stored in Registry.  persistor  is the list of activated persistors. BackBee will loop into each and try to find configuration. If no one\n  provides the requested configuration, an exception will be thrown.", 
            "title": "Configuration persisting"
        }, 
        {
            "location": "/developer-documentation/components/config/#configuration-caching", 
            "text": "The BackBee Config Component is fully compatible with BackBee Cache component.  When you create your Config object, you can pass an instance of  BackBee\\Cache\\AbstractCache  as a second argument.\nThis way, in a non-debug mode (fourth argument,  false  by default), the second time you get the information, the configuration\nwill be constructed from cache instead of built again from files or database registry.", 
            "title": "Configuration caching"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/", 
            "text": "Components\n\n\nThe Event Listener Component\n\n\nEvents\n are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occurred during a process. If a \ncomponent\n is\ninterested in a particular event, it can \nlisten\n to it. When this particular event is triggered, a \nmethod\n,\noften called \ncallback\n or \nhandler\n is executed. Events are convenient ways to share\ndata between components.\nIn \nBackBee\n, events are triggered by an \nEventDispatcher\n and an \nEventListener\n is used to listen to them.\n\n\nEvent\n\n\nNamespace: BackBee\\Event\\Event\n\n\nThe Backbee event class extend \nsfEvent\n and allows us to create a generic \nEvent\n object.\nA generic event object has two properties: \ntarget\n and \nargs\n;\nThe target property represents the target of the event. The \nargs\n is an optional associated map.\nWhen the \nargs\n property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class \nBackBee\\Event\\Event\n.\n\n\n?php\n$myHelloEvent = new Event($target, array(\nmessage\n=\nHello BackBee\n);\n\n\n\n\n\nEvent Listener\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nTo listen to an event you must use the \naddListener\n method of the \nEventDispatcher\n.\n\naddListener\n takes three parameters. The first one is the name of the event that will be triggered, the second is an array which first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.\n\n\n$this-\napplication-\ngetEventDispatcher()-\naddListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));\n\n\n\nHere, we register the listener \nHelloListener\n to be executed when the event \nloading.event\n is occured.\n\n\n    \n?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event-\ngetDispatcher();\n\n                if ($event-\nhasArguments(\nmessage\n)) {\n                    $message = $event-\nget(\nmessage\n);\n                    if ( null !== $dispatcher-\ngetApplication()) {\n                        $dispatcher-\ngetApplication()-\ngetLogging()-\nnotice($message);\n                    }\n                }\n            }\n        }\n\n    ?\n\n\n\n\n\nNotice that the event object has access to the \napplication\n \nvia\n the \nEventDispacher\n and that the \nsayHello\n is a \nstatic\n method.\n\n\nEvent Dispatcher\n\n\nNamespace: BackBee\\Event\\EventListener\n\n\nEvents are \ndispatched\n or \ntriggered\n by the \nEventDispatcher\n by using the method \ntriggerEvent\n. The sample bellow shows how to listen to an event.\n\n\nTo trigger an event, we must use the \nEventDispatcher\n. It provides, among others, a \ndispatch\n method that takes two arguments. A name and an event object.\n\n\n?php\n    $this-\napplication-\ngetEventDispatcher()-\ndispatch(\nloading.event\n, $myHelloEvent);\n\n\n\n\nWhen the \nloading.event\n is dispatched by the \nEventDispatcher\n, all the registered listeners will be executed. In our example,\nthe static \nsayHello\n method of the \nBackbee/Event/Listener/HelloListener\n will be called.\n\n\nEvents from Class Content Component\n\n\nOne of the main purposes of \nBackbee\n is to render contents. As we have seen, \ncontent is defined in a \n.yml\n file. Content creation and content rendering goes\nthrough many phases that \nBackbee\n exposes with events. For instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process starts, while the content is been rendered, after the renderer process and so on. These events\nallow us to act in different ways on the contents lifecycle and rendering process itself.\n\n\nClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an \nevent.yml\n config file.\nBellow is an example of how to use the file.\n\n\n# /repository/Config/event.yml\n    article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]\n\n\n\n\nevents.yml\n is a declarative way to add listeners to \nClassContentEvents\n event. Under the hook,\nthis yaml file is parsed and the \nEventDispatcher\n is used to register the listeners.\nIn our example,  \narticle.article.render\n and \nsocial.facebook.prerender\n are events names.\nBy convention \nBackBee\n transforms ClassContent class path to event name. Let's take a look at our events files.\n\n\nAccording to our \nevent.yml\n, the \narticle.article.render\n event will be triggered when\nthe content \nClassContent/Article/Article.yml\n is about to be rendered whereas\nthe 'social.facebook.prerender' will be triggered \nbefore\n the content \nClassContent/Social/Facebook.yml\n\nis rendered.\n\n*.render\n  and \n*.prerender\n are events dispatched during the rendering of pahe. Bellow is the list of\nall the Renderer events.\n\n\n\n\n*.prerender\n : is triggered \nbefore\n the content is being rendered;\n\n\n*.render\n : when the content is about to be rendered;\n\n\n*.postrender\n : after the render process.\n\n\n\n\nHowever there is no strong difference between \nrender\n and \npostrender\n.\n\n\nIn BackBee all contents behave like \nDoctrine\n entities. These doctrine events are also available for all the contents.\n\n\n\n\npreremove\n\n\npostremove\n\n\npostupdate\n\n\npreupdate\n\n\nupdate\n\n\nprepersist\n\n\npostpersist\n\n\npostload\n\n\nonflush\n\n\n\n\nClassContent Listener\n\n\nTo listen to a ClassContentEvent we have to create a \nListener\n class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.\n\n\n    \n?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event-\ngetEventArgs();\n\n                /* The eventDispatcher */\n                $eventDispatcher = $event-\ngetDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDispatcher-\ngetApplication();\n\n                /* The article classcontent */\n                $content = $renderer-\ngetObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer-\nassign('myParams', \nmy Param value\n);\n            }\n        }\n    ?\n\n\n\n\n\nEvent inheritance\n\n\nIn \nBackBee\n content can be inherited from one another. The \nEventDispatcher\n respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So \nclass content\n Events bubbles up in BackBee.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#the-event-listener-component", 
            "text": "Events  are a common and effective way to tie together loosely coupled components in an application.\nAn event is generally used to broadcast a change that has occurred during a process. If a  component  is\ninterested in a particular event, it can  listen  to it. When this particular event is triggered, a  method ,\noften called  callback  or  handler  is executed. Events are convenient ways to share\ndata between components.\nIn  BackBee , events are triggered by an  EventDispatcher  and an  EventListener  is used to listen to them.", 
            "title": "The Event Listener Component"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#event", 
            "text": "Namespace: BackBee\\Event\\Event  The Backbee event class extend  sfEvent  and allows us to create a generic  Event  object.\nA generic event object has two properties:  target  and  args ;\nThe target property represents the target of the event. The  args  is an optional associated map.\nWhen the  args  property is provided, it's sent to the listeners.\nCustom Event can be created by extending the class  BackBee\\Event\\Event .  ?php\n$myHelloEvent = new Event($target, array( message = Hello BackBee );", 
            "title": "Event"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#event-listener", 
            "text": "Namespace: BackBee\\Event\\EventListener  To listen to an event you must use the  addListener  method of the  EventDispatcher . addListener  takes three parameters. The first one is the name of the event that will be triggered, the second is an array which first element\nis a class path and the second is a method. The last parameter is the priority of the event. Listener with higher priority will be triggered first.  $this- application- getEventDispatcher()- addListener(\"loading.event\", array(\"BackBee/Event/Listener/HelloListener\", \"sayHello\"));  Here, we register the listener  HelloListener  to be executed when the event  loading.event  is occured.       ?php\n\n        namespace BackBee\\Event\\Listener;\n        use BackBee\\Event\\Event;\n\n        class HelloListener {\n\n            public static sayHello (Event $event) {\n\n                $dispatcher = $event- getDispatcher();\n\n                if ($event- hasArguments( message )) {\n                    $message = $event- get( message );\n                    if ( null !== $dispatcher- getApplication()) {\n                        $dispatcher- getApplication()- getLogging()- notice($message);\n                    }\n                }\n            }\n        }\n\n    ?   Notice that the event object has access to the  application   via  the  EventDispacher  and that the  sayHello  is a  static  method.", 
            "title": "Event Listener"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#event-dispatcher", 
            "text": "Namespace: BackBee\\Event\\EventListener  Events are  dispatched  or  triggered  by the  EventDispatcher  by using the method  triggerEvent . The sample bellow shows how to listen to an event.  To trigger an event, we must use the  EventDispatcher . It provides, among others, a  dispatch  method that takes two arguments. A name and an event object.  ?php\n    $this- application- getEventDispatcher()- dispatch( loading.event , $myHelloEvent);  When the  loading.event  is dispatched by the  EventDispatcher , all the registered listeners will be executed. In our example,\nthe static  sayHello  method of the  Backbee/Event/Listener/HelloListener  will be called.", 
            "title": "Event Dispatcher"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#events-from-class-content-component", 
            "text": "One of the main purposes of  Backbee  is to render contents. As we have seen, \ncontent is defined in a  .yml  file. Content creation and content rendering goes\nthrough many phases that  Backbee  exposes with events. For instance, an event is triggered\nwhen a content is created, before and after a content has been saved, when the rendering process starts, while the content is been rendered, after the renderer process and so on. These events\nallow us to act in different ways on the contents lifecycle and rendering process itself.  ClassContent events are similar to custom events. But, as they take place when the main application\nis dealing with a request, a common way to listen to them is to use an  event.yml  config file.\nBellow is an example of how to use the file.  # /repository/Config/event.yml\n    article.article.render:\n        listeners:\n            - [BackBee\\Event\\Listener\\ArticleListener, onRender]\n\n    social.facebook.prerender:\n        listeners:\n            - [BackBee\\Event\\Listener\\Socialistener, PrerenderFacebook]  events.yml  is a declarative way to add listeners to  ClassContentEvents  event. Under the hook,\nthis yaml file is parsed and the  EventDispatcher  is used to register the listeners.\nIn our example,   article.article.render  and  social.facebook.prerender  are events names.\nBy convention  BackBee  transforms ClassContent class path to event name. Let's take a look at our events files.  According to our  event.yml , the  article.article.render  event will be triggered when\nthe content  ClassContent/Article/Article.yml  is about to be rendered whereas\nthe 'social.facebook.prerender' will be triggered  before  the content  ClassContent/Social/Facebook.yml \nis rendered. *.render   and  *.prerender  are events dispatched during the rendering of pahe. Bellow is the list of\nall the Renderer events.   *.prerender  : is triggered  before  the content is being rendered;  *.render  : when the content is about to be rendered;  *.postrender  : after the render process.   However there is no strong difference between  render  and  postrender .  In BackBee all contents behave like  Doctrine  entities. These doctrine events are also available for all the contents.   preremove  postremove  postupdate  preupdate  update  prepersist  postpersist  postload  onflush", 
            "title": "Events from Class Content Component"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#classcontent-listener", 
            "text": "To listen to a ClassContentEvent we have to create a  Listener  class. By default BackBee\nwill look for Listener in the repository/Config/Listener folder.       ?php\n        namespace BackBee\\Event\\Listener,\n        use BackBee\\Event\\Event;\n\n        class ArticleListener extends Event {\n\n            public static function onRender(Event $event){\n                /* The renderer object */\n                $renderer = $event- getEventArgs();\n\n                /* The eventDispatcher */\n                $eventDispatcher = $event- getDispatcher();\n\n                /* the BackBee application */\n                $application = $eventDispatcher- getApplication();\n\n                /* The article classcontent */\n                $content = $renderer- getObject();\n\n                /* Add a new parameter that will be available in the content template */\n                $renderer- assign('myParams',  my Param value );\n            }\n        }\n    ?", 
            "title": "ClassContent Listener"
        }, 
        {
            "location": "/developer-documentation/components/event_listener/#event-inheritance", 
            "text": "In  BackBee  content can be inherited from one another. The  EventDispatcher  respects this inheritance.\nIf an event is triggered for a subContent it will also be triggered for its parents. So  class content  Events bubbles up in BackBee.", 
            "title": "Event inheritance"
        }, 
        {
            "location": "/developer-documentation/components/nested_node/", 
            "text": "Components\n\n\nThe NestedNode Component\n\n\nWhat is it\n\n\nNestedNode component regroups every BackBee object using the Nested set model. In this component, you can find \nKeyWord\n, \nMedia\n, \nMediaFolder\n, \nPage\n and \nSection\n.\n\n\nNested set model\n\n\n\n\nThe nested set model is to set to count the nodes according to a tree traversal, which visits each node twice, assigning numbers in the visiting order, and at both visits. This leaves two numbers for each node, which are stored as two attributes. Querying becomes inexpensive: hierarchy membership can be tested by comparing these numbers. Updating requires renumbering and is therefore expensive. Refinements that use rational numbers instead of integers can avoid renumbering, and so are faster to update, although much more complicated.\n\n\nwiki\n\n\n\n\nKeyWord\n\n\nKeyWord entity is a hierarchical tree of keywords.\n\n\nKeyWord in CMS are used as keyword, tag and in rare case category. These words can be attach to a \nClassContent\n by using the native content Keyword.\n\n\nMedia and MediaFolder\n\n\nMediaFolder entity is a hierarchical tree of folders that contain Media.\n\n\nThese two objects are used in the Media library and like the KeyWord Object, Media is attached to a ClassContent and more precisely all media with this namespace \nBackBee\\ClassContent\\Media\n\n\nPage and Section\n\n\nPage and Section works like Media and MediaFolder. Only Sections are hierarchical entities.\n\n\nTo lighten the page Nested set model, the BackBee team has decided to make a distinction between pages with children (sections) and pages without children (pages).\n\n\nWhen you create new pages it has a reference to a section. It will automatically become a section when you attach a child to it.\n\n\nCreate a page by the code\n\n\nTo ease page creation, we recommend you to use PageBuilder. See an example below:\n\n\n?php\n// retrieve an application instanced or create new application\n$app = new \\BackBee\\Standard\\Application();\n// Load the layout\n$layout = $app-\ngetEntityManager()-\ngetRepository('BackBuilder\\Site\\Layout')-\nfindBy(['label' =\n 'Home']);\n\n$page = $app-\ngetContainer()-\nget('pagebuilder')\n// Add an title to your page\n  -\nsetTitle('My awesome Page')\n// Add an Layout\n  -\nsetLayout($layout)\n// Add Site where your page is available\n  -\nsetSite($app-\ngetSite())\n// Define your page as onlinne\n  -\nputOnlineAndHidden()\n// Add a content inner your page\n  -\npushElement(new \\BackBee\\ClassContent\\Article\\Article())\n  -\ngetPage();\n\n$app-\ngetEntityManager-\npersist($page);\n$app-\ngetEntityManager-\nflush($page);", 
            "title": "Nested Node"
        }, 
        {
            "location": "/developer-documentation/components/nested_node/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/nested_node/#the-nestednode-component", 
            "text": "What is it  NestedNode component regroups every BackBee object using the Nested set model. In this component, you can find  KeyWord ,  Media ,  MediaFolder ,  Page  and  Section .  Nested set model   The nested set model is to set to count the nodes according to a tree traversal, which visits each node twice, assigning numbers in the visiting order, and at both visits. This leaves two numbers for each node, which are stored as two attributes. Querying becomes inexpensive: hierarchy membership can be tested by comparing these numbers. Updating requires renumbering and is therefore expensive. Refinements that use rational numbers instead of integers can avoid renumbering, and so are faster to update, although much more complicated.  wiki   KeyWord  KeyWord entity is a hierarchical tree of keywords.  KeyWord in CMS are used as keyword, tag and in rare case category. These words can be attach to a  ClassContent  by using the native content Keyword.  Media and MediaFolder  MediaFolder entity is a hierarchical tree of folders that contain Media.  These two objects are used in the Media library and like the KeyWord Object, Media is attached to a ClassContent and more precisely all media with this namespace  BackBee\\ClassContent\\Media  Page and Section  Page and Section works like Media and MediaFolder. Only Sections are hierarchical entities.  To lighten the page Nested set model, the BackBee team has decided to make a distinction between pages with children (sections) and pages without children (pages).  When you create new pages it has a reference to a section. It will automatically become a section when you attach a child to it.  Create a page by the code  To ease page creation, we recommend you to use PageBuilder. See an example below:  ?php\n// retrieve an application instanced or create new application\n$app = new \\BackBee\\Standard\\Application();\n// Load the layout\n$layout = $app- getEntityManager()- getRepository('BackBuilder\\Site\\Layout')- findBy(['label' =  'Home']);\n\n$page = $app- getContainer()- get('pagebuilder')\n// Add an title to your page\n  - setTitle('My awesome Page')\n// Add an Layout\n  - setLayout($layout)\n// Add Site where your page is available\n  - setSite($app- getSite())\n// Define your page as onlinne\n  - putOnlineAndHidden()\n// Add a content inner your page\n  - pushElement(new \\BackBee\\ClassContent\\Article\\Article())\n  - getPage();\n\n$app- getEntityManager- persist($page);\n$app- getEntityManager- flush($page);", 
            "title": "The NestedNode Component"
        }, 
        {
            "location": "/developer-documentation/components/renderer/", 
            "text": "Components\n\n\nThe Renderer Component\n\n\nThe Renderer component is used to render any content from BackBee core.\nIt provides a \nRenderer\n object able to:\n\n\n\n\nSearch for templates according to available adapters;\n\n\nRender BackBee \nPage\n but also any \nClassContent\n;\n\n\nAccept multiple rendering modes for each content to be rendered;\n\n\nCan Render only an HTML fragment;\n\n\nManage Web assets (CSS and Javascripts).\n\n\n\n\nThe Big picture\n\n\nLet's start with a schema that represents BackBee architecture on a simple page:\n\n\n\n\nEach element has an objective representation inside \nBackBee core library\n:\n\n\n\n\nSite\n (\nBackBuilder\\Site\\Site\n) is your application.\n\n\nPage\n (\nBackBuilder\\NestedNode\\Page\n) represents each page of your application, for example BackBee CMS provide three pages: home page, article page and category page.\n\n\nLayout\n (\nBackBuilder\\Site\\Layout\n) represents the layout of a page.\n\n\nContentSet\n (\nBackBuilder\\ClassContent\\ContentSet\n) represent the blocks/columns of layouts, which can be edited by user.\n\n\n\n\nWhen an user accesses to a page, the \nRenderer::render()\n method is called.\n\n\n\n\nDuring the rendering process, three events are dispatched: \nprerender\n, \nrender\n and \npostrender\n.\n\n\n\n\nRenderer adapters and manageable extensions\n\n\nThe BackBee Renderer Component is able to render different templating engines thanks to Adapters.\nIn BackBee Standard Edition, two adapters are provided:\n\n The \nPHTML\n Adapter\n\n The \nTwig\n Adapter\n\n\nWhen BackBee tries to render content, it looks for a template and then it looks for the file extension.\nIf the extension file is part of manageable extensions and if an Adapter is found for this extension, the Adapter is called to render the template with the assigned variables.\n\n\nTo implement your own adapter, for \nSmarty\n you need to implement the \nBackBee\\Renderer\\RendererAdapterInterface\n interface.\n\n\n?php\n\n/*\n * Copyright (c) 2011-2015 Lp digital system\n *\n * This file is part of BackBee.\n *\n * BackBee is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * BackBee is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with BackBee. If not, see \nhttp://www.gnu.org/licenses/\n.\n *\n * @author Charles Rouillon \ncharles.rouillon@lp-digital.fr\n\n */\n\nnamespace BackBee\\Renderer;\n\nuse BackBee\\Site\\Layout;\n\n/**\n * Interface for a renderer adapter.\n *\n * @category    BackBee\n *\n * @copyright   Lp digital system\n * @author      e.chau \neric.chau@lp-digital.fr\n\n */\ninterface RendererAdapterInterface\n{\n    /**\n     * Constructor; every RendererAdapter need to be construct with a AbstractRenderer\n     *\n     * @param AbstractRenderer $renderer\n     */\n    public function __construct(AbstractRenderer $renderer, array $config = []);\n\n    /**\n     * Returns array that contains every single file's extension managed by this adapter.\n     *\n     * @return array\n     */\n    public function getManagedFileExtensions();\n\n    /**\n     * Check if $filename exist in $templateDir; it also checks if the file is readable.\n     *\n     * @param string $filename\n     * @param array  $templateDir array that contains every directories where it has to looking\n     *                            for $filename\n     *\n     * @return boolean true if the filename was found into $templateDir and it's readable,\n     *                 else it returns false\n     */\n    public function isValidTemplateFile($filename, array $templateDir);\n\n    /**\n     * Returns render of $filename template which is compute with $params and $vars.\n     *\n     * @param string $filename\n     * @param array  $templateDir\n     * @param array  $params\n     *\n     * @return string\n     */\n    public function renderTemplate($filename, array $templateDir, array $params = array(), array $vars = array());\n\n    /**\n     * Updates a file script of a layout.\n     *\n     * @param Layout $layout     The layout to update\n     * @param string $layoutFile the layout with absolute path generated by ARendrer::updateLayout()\n     *\n     * @return string The filename of the updated script\n     */\n    public function updateLayout(Layout $layout, $layoutFile);\n\n    /**\n     * This is called everytime we clone a renderer.\n     *\n     * @param Renderer $renderer the new renderer\n     */\n    public function onNewRenderer(AbstractRenderer $renderer);\n\n    /**\n     * This is called everytime we restore previous renderer.\n     *\n     * @param Renderer $renderer the previous renderer\n     */\n    public function onRestorePreviousRenderer(AbstractRenderer $renderer);\n}\n\n\n\n\n\nAn adapter can also extend \nBackBee\\Renderer\\AbstractRendererAdapter\n to help you focus only on templating engine specifications you want to support.\n\n\nRender a Page / ClassContent\n\n\nRendering a Page or a ClassContent starts in the \nRenderer::render()\n method:\n\n\n?php\n// in the BackBee Renderer class\npublic function render(\n    RenderableInterface $obj = null,\n    $mode = null,\n    $params = null,\n    $template = null,\n    $ignoreModeIfNotSet = false\n    ){ /* rendering is done here */ }\n}\n\n\n\n\nIf the object is an instance of \nBackBee\\Site\\Page\n, the function \nrenderPage\n is called inside \nrender()\n function.\n\n\n\n\n\n\nThis method loads the Page Layout object and then loops into all the ContentSet objects, and for each ContentSet loop into all the ClassContents and try to render them.\n\n\n\n\n\n\nFinally, it uses the template related to the layout through the method \nrenderTemplate\n which calls the selected \nAdapter::renderTemplate()\n function.\n\n\n\n\n\n\nElse, if the object is not a Page instance, the function \nrenderContent()\n is directly called.\n\n\nIf the object is nil or doesn't implement \nRenderableInterface\n interface, the Renderer doesn't return an exception but nothing.\n\n\nPartial rendering\n\n\nBackBee Renderer component can render partial HTML fragments. Under the hood, this is the \nrenderPartial()\n method which is used to render the HTML fragment.\n\n\n// in the BackBee Renderer class\n\npublic function partial($template = null, $params = null)\n{\n    // return a partial content\n}\n\n\n\n\nTo call a partial in your template, the file needs to be in \nrepository/Templates/scripts/partials\n folder:\n\n\n!DOCTYPE html\n\n\nhtml lang=\nfr\n\n\n    {{ this.partial('partials/header-head.twig')|raw }}\n\n    \nbody\n\n    \n!-- ... --\n\n    \n/body\n\n\n/html\n\n\n\n\n\n\n\nIf you use a partial, you can use the helpers to inject the styles and the javascripts because they are not called inside the partials.\n\n\n\n\nAsset management\n\n\nIn addition, the BackBee Renderer Component provides nice helpers to help you add assets dynamically.\n\n\nBackBee helps you add any resource available in your application, here is a list of available helpers:\n\n\n\n\ngetImageUrl\n, \ngetMediaUrl\n and \ngetResourceUrl\n : get any file from any \nResource\n folder (both in application and bundles);\n\n\ngetUri\n : get any file from the \npublic\n folder of an BackBee application;\n\n\naddStylesheet\n, \naddHeaderJs\n and \naddFooterJs\n allowing you to generate the correct CSS or Javascript call. For the Javascript files you can choose to import Javascript in the \nheader\n or in the bottom of the \nbody\n;\n\n\ngetUrlByRouteName\n is another helper to manage urls of an application.\n\n\n\n\nGlobal variables\n\n\nThe BackBee Renderer Component embeds some useful variables in each template from the BackBee application.\n\n\n?php\n// in the BackBee Renderer class\n/**\n     * Returns default parameters that are availables in every templates.\n     *\n     * @return array\n     */\n    private function getBBVariable()\n    {\n        return [\n            'bb' =\n [\n                'debug'      =\n $this-\ngetApplication()-\nisDebugMode(),\n                'token'      =\n $this-\ngetApplication()-\ngetBBUserToken(),\n                'request'    =\n $this-\ngetApplication()-\ngetRequest(),\n                'routing'    =\n $this-\ngetApplication()-\ngetRouting(),\n                'translator' =\n $this-\ngetApplication()-\ngetContainer()-\nget('translator'),\n            ],\n        ];\n    }\n\n\n\n\nThanks to helpers, in template you can retrieve useful informations:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n\n/head\n\n    \nbody\n\n        \n?php if($this-\ntoken !== null) ?\n\n        Hi \n?php echo $this-\ntoken-\ngetUser()-\ngetUsername(); ?\n\n        \n?php else : ?\n\n        You are non authenticated.\n        \n?php endif; ?\n\n    \n/body\n\n\n/html\n\n\n\n\n\nIn BackBee Standard application, theses additional helpers are available:\n\n\n\n\nbbtoolbar()\n : display the toolbar application. \nYou need to have an element with the CSS identifier \nbb5-site-wrapper\n or else the application has bad design behaviors\n.\n\n\nnavbar()\n : display a menu for all pages that have the \"display in the menus\" option activated.\n\n\ncontainer()\n allows you to loop into the contentset of your layout and then, design your page.\n\n\n\n\nFor a complete example, you can take a look at the \nArticle\n layout:\n\n\n!DOCTYPE html\n\n\nhtml lang=\nfr\n\n    {{ this.partial('partials/header-head.twig')|raw }}\n    \nbody\n\n        {{ this.bbtoolbar()|raw }} {# When logged, display the toolbar #}\n        \ndiv id=\nbb5-site-wrapper\n\n            {{ this.navbar()|raw }} {# display the menu #}\n            \n!-- Some content --\n\n            \ndiv class=\nrow relative\n id=\nbb5-mainLayoutRow\n\n                \ndiv class=\ncol-sm-12 col-md-10\n\n                    {{ this.container().first()|raw }}\n                \n/div\n\n                \ndiv class=\ncol-md-2 visible-md\n id=\nsidebar\n data-scroller=\ntrue\n\n                    {{ this.container().next()|raw }}\n                \n/div\n\n            \n/div\n\n        \n/div\n!-- End BackBee Site wrapper --\n\n    \n/body\n\n\n/html", 
            "title": "Renderer"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#the-renderer-component", 
            "text": "The Renderer component is used to render any content from BackBee core.\nIt provides a  Renderer  object able to:   Search for templates according to available adapters;  Render BackBee  Page  but also any  ClassContent ;  Accept multiple rendering modes for each content to be rendered;  Can Render only an HTML fragment;  Manage Web assets (CSS and Javascripts).", 
            "title": "The Renderer Component"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#the-big-picture", 
            "text": "Let's start with a schema that represents BackBee architecture on a simple page:   Each element has an objective representation inside  BackBee core library :   Site  ( BackBuilder\\Site\\Site ) is your application.  Page  ( BackBuilder\\NestedNode\\Page ) represents each page of your application, for example BackBee CMS provide three pages: home page, article page and category page.  Layout  ( BackBuilder\\Site\\Layout ) represents the layout of a page.  ContentSet  ( BackBuilder\\ClassContent\\ContentSet ) represent the blocks/columns of layouts, which can be edited by user.   When an user accesses to a page, the  Renderer::render()  method is called.   During the rendering process, three events are dispatched:  prerender ,  render  and  postrender .", 
            "title": "The Big picture"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#renderer-adapters-and-manageable-extensions", 
            "text": "The BackBee Renderer Component is able to render different templating engines thanks to Adapters.\nIn BackBee Standard Edition, two adapters are provided:  The  PHTML  Adapter  The  Twig  Adapter  When BackBee tries to render content, it looks for a template and then it looks for the file extension.\nIf the extension file is part of manageable extensions and if an Adapter is found for this extension, the Adapter is called to render the template with the assigned variables.  To implement your own adapter, for  Smarty  you need to implement the  BackBee\\Renderer\\RendererAdapterInterface  interface.  ?php\n\n/*\n * Copyright (c) 2011-2015 Lp digital system\n *\n * This file is part of BackBee.\n *\n * BackBee is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * BackBee is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with BackBee. If not, see  http://www.gnu.org/licenses/ .\n *\n * @author Charles Rouillon  charles.rouillon@lp-digital.fr \n */\n\nnamespace BackBee\\Renderer;\n\nuse BackBee\\Site\\Layout;\n\n/**\n * Interface for a renderer adapter.\n *\n * @category    BackBee\n *\n * @copyright   Lp digital system\n * @author      e.chau  eric.chau@lp-digital.fr \n */\ninterface RendererAdapterInterface\n{\n    /**\n     * Constructor; every RendererAdapter need to be construct with a AbstractRenderer\n     *\n     * @param AbstractRenderer $renderer\n     */\n    public function __construct(AbstractRenderer $renderer, array $config = []);\n\n    /**\n     * Returns array that contains every single file's extension managed by this adapter.\n     *\n     * @return array\n     */\n    public function getManagedFileExtensions();\n\n    /**\n     * Check if $filename exist in $templateDir; it also checks if the file is readable.\n     *\n     * @param string $filename\n     * @param array  $templateDir array that contains every directories where it has to looking\n     *                            for $filename\n     *\n     * @return boolean true if the filename was found into $templateDir and it's readable,\n     *                 else it returns false\n     */\n    public function isValidTemplateFile($filename, array $templateDir);\n\n    /**\n     * Returns render of $filename template which is compute with $params and $vars.\n     *\n     * @param string $filename\n     * @param array  $templateDir\n     * @param array  $params\n     *\n     * @return string\n     */\n    public function renderTemplate($filename, array $templateDir, array $params = array(), array $vars = array());\n\n    /**\n     * Updates a file script of a layout.\n     *\n     * @param Layout $layout     The layout to update\n     * @param string $layoutFile the layout with absolute path generated by ARendrer::updateLayout()\n     *\n     * @return string The filename of the updated script\n     */\n    public function updateLayout(Layout $layout, $layoutFile);\n\n    /**\n     * This is called everytime we clone a renderer.\n     *\n     * @param Renderer $renderer the new renderer\n     */\n    public function onNewRenderer(AbstractRenderer $renderer);\n\n    /**\n     * This is called everytime we restore previous renderer.\n     *\n     * @param Renderer $renderer the previous renderer\n     */\n    public function onRestorePreviousRenderer(AbstractRenderer $renderer);\n}  An adapter can also extend  BackBee\\Renderer\\AbstractRendererAdapter  to help you focus only on templating engine specifications you want to support.", 
            "title": "Renderer adapters and manageable extensions"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#render-a-page-classcontent", 
            "text": "Rendering a Page or a ClassContent starts in the  Renderer::render()  method:  ?php\n// in the BackBee Renderer class\npublic function render(\n    RenderableInterface $obj = null,\n    $mode = null,\n    $params = null,\n    $template = null,\n    $ignoreModeIfNotSet = false\n    ){ /* rendering is done here */ }\n}  If the object is an instance of  BackBee\\Site\\Page , the function  renderPage  is called inside  render()  function.    This method loads the Page Layout object and then loops into all the ContentSet objects, and for each ContentSet loop into all the ClassContents and try to render them.    Finally, it uses the template related to the layout through the method  renderTemplate  which calls the selected  Adapter::renderTemplate()  function.    Else, if the object is not a Page instance, the function  renderContent()  is directly called.  If the object is nil or doesn't implement  RenderableInterface  interface, the Renderer doesn't return an exception but nothing.", 
            "title": "Render a Page / ClassContent"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#partial-rendering", 
            "text": "BackBee Renderer component can render partial HTML fragments. Under the hood, this is the  renderPartial()  method which is used to render the HTML fragment.  // in the BackBee Renderer class\n\npublic function partial($template = null, $params = null)\n{\n    // return a partial content\n}  To call a partial in your template, the file needs to be in  repository/Templates/scripts/partials  folder:  !DOCTYPE html  html lang= fr \n\n    {{ this.partial('partials/header-head.twig')|raw }}\n\n     body \n     !-- ... -- \n     /body  /html    If you use a partial, you can use the helpers to inject the styles and the javascripts because they are not called inside the partials.", 
            "title": "Partial rendering"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#asset-management", 
            "text": "In addition, the BackBee Renderer Component provides nice helpers to help you add assets dynamically.  BackBee helps you add any resource available in your application, here is a list of available helpers:   getImageUrl ,  getMediaUrl  and  getResourceUrl  : get any file from any  Resource  folder (both in application and bundles);  getUri  : get any file from the  public  folder of an BackBee application;  addStylesheet ,  addHeaderJs  and  addFooterJs  allowing you to generate the correct CSS or Javascript call. For the Javascript files you can choose to import Javascript in the  header  or in the bottom of the  body ;  getUrlByRouteName  is another helper to manage urls of an application.", 
            "title": "Asset management"
        }, 
        {
            "location": "/developer-documentation/components/renderer/#global-variables", 
            "text": "The BackBee Renderer Component embeds some useful variables in each template from the BackBee application.  ?php\n// in the BackBee Renderer class\n/**\n     * Returns default parameters that are availables in every templates.\n     *\n     * @return array\n     */\n    private function getBBVariable()\n    {\n        return [\n            'bb' =  [\n                'debug'      =  $this- getApplication()- isDebugMode(),\n                'token'      =  $this- getApplication()- getBBUserToken(),\n                'request'    =  $this- getApplication()- getRequest(),\n                'routing'    =  $this- getApplication()- getRouting(),\n                'translator' =  $this- getApplication()- getContainer()- get('translator'),\n            ],\n        ];\n    }  Thanks to helpers, in template you can retrieve useful informations:  !DOCTYPE html  html  head  /head \n     body \n         ?php if($this- token !== null) ? \n        Hi  ?php echo $this- token- getUser()- getUsername(); ? \n         ?php else : ? \n        You are non authenticated.\n         ?php endif; ? \n     /body  /html   In BackBee Standard application, theses additional helpers are available:   bbtoolbar()  : display the toolbar application.  You need to have an element with the CSS identifier  bb5-site-wrapper  or else the application has bad design behaviors .  navbar()  : display a menu for all pages that have the \"display in the menus\" option activated.  container()  allows you to loop into the contentset of your layout and then, design your page.   For a complete example, you can take a look at the  Article  layout:  !DOCTYPE html  html lang= fr \n    {{ this.partial('partials/header-head.twig')|raw }}\n     body \n        {{ this.bbtoolbar()|raw }} {# When logged, display the toolbar #}\n         div id= bb5-site-wrapper \n            {{ this.navbar()|raw }} {# display the menu #}\n             !-- Some content -- \n             div class= row relative  id= bb5-mainLayoutRow \n                 div class= col-sm-12 col-md-10 \n                    {{ this.container().first()|raw }}\n                 /div \n                 div class= col-md-2 visible-md  id= sidebar  data-scroller= true \n                    {{ this.container().next()|raw }}\n                 /div \n             /div \n         /div !-- End BackBee Site wrapper -- \n     /body  /html", 
            "title": "Global variables"
        }, 
        {
            "location": "/developer-documentation/components/routing/", 
            "text": "Components\n\n\nThe Routing Component\n\n\nThis component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of \nSymfony Routing Component\n, so the official documentation is\nstill valid.\n\n\nHow the Routing component work ?\n\n\nTo set a basic routing system, you need at least to set and configure three objects:\n\n\n\n\nA \nBackBee\\Routing\\RouteCollection\n instance, which contains routes definitions (instance of \nBackBee\\Routing\\Route\n);\n\n\nA \nBackBee\\Routing\\RequestContext\n instance, which embed the current request;\n\n\nFinaly, a \nRequestMatcher\n instance, in charge of performs the mapping from request to a Route.\n\n\n\n\nIn BackBee CMS, all routes are declared in \nBackBee/Config/route.yml\n file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).\n\n\nThe \nroute.yml\n is parsed by the Yaml component and BackBee create a \nRouteCollection\n instance, which is stored in Container as the\n\nrouting\n service (Symfony developpers should notice this behavior is a little bit different to the Symfony \nrouter\n service which is not available in BackBee).\n\n\nIn this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.\n\n\nAlso, some routes are defined to handle some resources and finaly the most important route is the default route.\n\n\nLet's take an example:\n\n\n# Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET\n\n\n\n\nA \nBackBee\\Route\n is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.\n\n\nRouting component requirements\n\n\nThe \nrequirements\n property allow use to add requirements used by the \nRequestMatcher\n to map an url to a request.\n\n\nThis is an example of some available requirements:\n\n\n# this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition: \ncontext.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'\n # use the Symfony Expression Language component\n\n\n\n\nThe \ncondition\n requirement can use the Symfony Expression Language component and have access to:\n\n \ncontext\n: the instance of RequestContext;\n\n \nrequest\n: the instance of the actual Request;\n\n\nIf you are interested in this component, you can take a look to the official \nExpression Language\n documentation.", 
            "title": "Routing"
        }, 
        {
            "location": "/developer-documentation/components/routing/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/routing/#the-routing-component", 
            "text": "This component is used in BackBee to map an HTTP request to a set of configuration variables.\nNote this component is an extension of  Symfony Routing Component , so the official documentation is\nstill valid.", 
            "title": "The Routing Component"
        }, 
        {
            "location": "/developer-documentation/components/routing/#how-the-routing-component-work", 
            "text": "To set a basic routing system, you need at least to set and configure three objects:   A  BackBee\\Routing\\RouteCollection  instance, which contains routes definitions (instance of  BackBee\\Routing\\Route );  A  BackBee\\Routing\\RequestContext  instance, which embed the current request;  Finaly, a  RequestMatcher  instance, in charge of performs the mapping from request to a Route.   In BackBee CMS, all routes are declared in  BackBee/Config/route.yml  file, but obviously you can create your own routes in Standard\nEdition if you have frameworks needs outside the \"CMS\" context (backend bundles for instance).  The  route.yml  is parsed by the Yaml component and BackBee create a  RouteCollection  instance, which is stored in Container as the routing  service (Symfony developpers should notice this behavior is a little bit different to the Symfony  router  service which is not available in BackBee).  In this file, you can find all the routes (and so on, paths) from the actual REST API used to communicate with the Javascript client when you are logged to BackBee Standard Edition.  Also, some routes are defined to handle some resources and finaly the most important route is the default route.  Let's take an example:  # Access all media\nbb.media.list:\n  pattern: /rest/{version}/medialist\n  defaults:\n    _action: medialistAction\n    _controller: BackBee\\Rest\\Controller\\MediaController # can be a service definition\n  requirements:\n    _method: GET  A  BackBee\\Route  is defined by a pattern (mostly an url path) where we can use variables, have some mandatory defaults\n(binded to a Controller and an action) and may have some requirements.", 
            "title": "How the Routing component work ?"
        }, 
        {
            "location": "/developer-documentation/components/routing/#routing-component-requirements", 
            "text": "The  requirements  property allow use to add requirements used by the  RequestMatcher  to map an url to a request.  This is an example of some available requirements:  # this route is very difficult to match\nroute.name:\n  pattern: /route/{a}/{b}/{c}/difficult\n  defaults:\n    _action: fooAction\n    _controller: Baz\\BarController\n  requirements:\n    a: .+ # accept regex conditions\n    b: \\d+\n    _method:POST\n    condition:  context.getMethod() in ['GET', 'HEAD'] and request.headers.get('User-Agent') matches '/firefox/i'  # use the Symfony Expression Language component  The  condition  requirement can use the Symfony Expression Language component and have access to:   context : the instance of RequestContext;   request : the instance of the actual Request;  If you are interested in this component, you can take a look to the official  Expression Language  documentation.", 
            "title": "Routing component requirements"
        }, 
        {
            "location": "/developer-documentation/components/security/", 
            "text": "Components\n\n\nThe Security Component\n\n\nBackBee\n Security component is based on the Security Component of \nSymfony\n.\n\n\nIt provides a robust way to secure a web application. Here we will present some of the core concepts of this component : \nfirewall\n, \nFirewallMap\n, \nauthentication\n , \nauthorization\n, \nDecissionAccess\n,  \nVoter\n, \nSecurityContext\n.\n\n\nOverview of security mechanism\n\n\nThe main purpose of the security component is to deal with \nauthentication\n and \nauthorization\n.\n\n\nAuthentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.\n\n\nAuthentication is handled by what is called a \nfirewall\n. An application can have many secured areas, an admin area for instance.\n\n\nA secured area is determined by an \nurl\n. When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.\n\n\nThe \nFirewall\n archives this by listening to the \nsymfony\n \nkernel.request\n event triggered by the HttpKernel.\nA \nFirewallMap\n maps a \nrequest\n with the registered listeners then checks if the current request is under a secured area or is already secured.\n\n\nA \nFirewallMap\n Listener can authenticate a request, throws an \nAuthenticationException\n or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an \nAccessDeniedHttpException\n or used to initiate an authentication process by calling the \nFirewall\n entry point.\n\n\nAuthentication\n\n\nA firewall entry point, as it implements the \nauthenticationEntryPointInterface\n, must provided a \nstart\n method which takes two parameters: a request and the exception previously raised.\n\n\nstart\n must return a \nResponse\n object that can be a page showing a form for instance.\nIf one of the \nFirewallMap\n Listener can handle the request, it creates a \nToken\n object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an \nauthenticationProviderManager\n object to authenticate the \nToken\n. \nauthenticationProviderManager\n will authenticate the token if provided and return an \nauthenticated\n one if the user credential is valid.\n\n\nOtherwise an \nAuthenticationException\n is raised.\nEach \nToken\n uses a specific type of \nauthenticationProvider\n. An \nauthenticationProvider\n must implements the \nauthenticationProviderInterface\n and provides the two methods :  \nauthentificate\n which takes one paramater that must implements the \nTokenInterface\n and \nsupports\n which is used to check whether or not the given \ntoken\n is supported by the authentication provider .\n\n\nRegistered FirewallMap Listeners must implement the \nListenerInterface\n thus provided an \nhandle\n method that accept an \nGetRequestEvent\n object.\n\n\nAuthorization\n\n\nOnce a user is identified his roles or any other attributes or object of its \ntoken\n can be used to determine whether or not he has access to a resource.\n\n\nDecision manager\n\n\nAn \nAccessControlManager\n is used to make final access decisions based on \nVoter\n.\n\n\nA voter can decide to \nvote\n either for grant or deny access to a ressource. A voter can also abstain itself.\n\n\nBy default The \nAccessControllerManagers\n make his decision according to one these three strategies:\n\n\n\n\naffirmative\n (Access is granted if any voter votes for granting access)\n\n\nconsensus\n (Access is granted if there are more voters willing to granting access then otherwise\n\n\nunanimous\n (Access is granted if all voters vote for granting access)\n\n\n\n\nUnderstand voters\n\n\nA voter class must implements the \nVoterInterface\n which has 4 methods:\n\n\n\n\nsupportsAttribute($attribute)\n\n\nsupportsClass($class)\n\n\nvote(TokentInterface $token, $object, $attributes)\n\n\n\n\nsupportsAttribute\n is used to check if the voter supports some attributes of the token.\n\nsupportClass\n is user to check it the voter supports a specific class\n\nvote\n handle the vote strategy and must return of those class Constant :\n\n\n\n\nVoterInterface::ACCESS_GRANTED\n\n\nVoterInterface::ACCESS_ABSTAIN\n\n\nVoterInterface::ACCESS_DENIED\n\n\n\n\nBellow is list of Voter used in BackBee\n\n AccessVoter\n\n BBAclVoter\n\n BBRoleVoter\n\n SudoVoter\n\n\nBackBee SecurityContext and the ContextInterface\n\n\nAll the process of creating \nFirewall\n, \nFirewallMap\n, \nAuthenticationManager\n, \nAccessDecisionMananger\n and listeners is handled by the \nBackBee\\Security\\SecurityContext\n object.\n\n\nHowever the way of dealing with security Listerners is simplyfied by using a \nContext\n object.\nA security \nContext\n extends the abstract class \nBackBee\\Security\\Context\\BBAuthContext\n and defines the \nloadListeners\n method.\n\n\nLoadListeners\n accepts one parameter which is the security config that can be setted in \nrepository/Config/security.yml\n.\nA context can be used to instanciate new listener or to register new authentication provider to the \nSecuriryContext\n.\n\n\nBellow we show all the  security contexts provided by BackBee.\n\n\n\n\nAnonymousContext\n\n\nBBAuthContext\n\n\nLogoutContext\n\n\nRestfulContext\n\n\nStatelessContext\n\n\nUsernamePasswordContext\n\n\n\n\nAnonymousContext\n\n\nAnonymouseContext\n is used to identify anonymous user.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\AnonymousToken\n\n\n\n\nBBAuthContext\n\n\nBBAuthContext\n is used to authentify a user by using the BackBee User table.\n\n\n\n\nauthentication provider\n : \nBackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\AnonymousAuthenticationListener\n\n\nToken\n : \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nLogoutContext\n\n\nLogoutContext\n handles user logout by removing all setted tokens.\n\n\n\n\nauthentication provider\n : \nnone\n\n\nToken\n : \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\LogoutListener\n\n\n\n\nRestfulContext\n\n\nRestfulContext\n is used to authentify rest user with a plublic key.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider\n\n\nListener\n : \nBackBee\\Security\\Listeners\\PublicKeyAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\BBUserToken\n\n\n\n\nStatelessContext\n\n\nIn stateless mode, authentication is asked for every requests. \nStatelessContext\n handles sessions\ncreation every time stateless mode is disabled.\n\n\n\n\nauthentication provider\n: \nnone\n\n\nListener\n: \nBackBee\\Security\\Listeners\\ContextListener\n\n\nToken\n: \nnone\n\n\n\n\nUsernamePasswordContext\n\n\nUsernamePasswordContext\nis used to authenticate user by using a login form.\n\n\n\n\nauthentication provider\n: \nBackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider\n\n\nListener\n: \nBackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener\n\n\nToken\n: \nBackBee\\Security\\Token\\UsernamePasswordToken\n\n\n\n\nConfiguring Security with \nsecurity.yml\n\n\nSecurity configurations can be handled with a simple yml file. This file can be found in \nrepository/Config/security.yml\n.\n\n\nfirewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Security"
        }, 
        {
            "location": "/developer-documentation/components/security/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/security/#the-security-component", 
            "text": "BackBee  Security component is based on the Security Component of  Symfony .  It provides a robust way to secure a web application. Here we will present some of the core concepts of this component :  firewall ,  FirewallMap ,  authentication  ,  authorization ,  DecissionAccess ,   Voter ,  SecurityContext .", 
            "title": "The Security Component"
        }, 
        {
            "location": "/developer-documentation/components/security/#overview-of-security-mechanism", 
            "text": "The main purpose of the security component is to deal with  authentication  and  authorization .  Authentication is a way to grant access to a ressource. When a user is successfully authentified, authorization is a way to control access to a specific ressource.  Authentication is handled by what is called a  firewall . An application can have many secured areas, an admin area for instance.  A secured area is determined by an  url . When an url that is part of a secured area is requested, behind the hook some registered callbacks are executed.  The  Firewall  archives this by listening to the  symfony   kernel.request  event triggered by the HttpKernel.\nA  FirewallMap  maps a  request  with the registered listeners then checks if the current request is under a secured area or is already secured.  A  FirewallMap  Listener can authenticate a request, throws an  AuthenticationException  or do nothing. If one of these listeners throw an exception (meaning that the request is not authentificated), this exception can either be transformed into an  AccessDeniedHttpException  or used to initiate an authentication process by calling the  Firewall  entry point.", 
            "title": "Overview of security mechanism"
        }, 
        {
            "location": "/developer-documentation/components/security/#authentication", 
            "text": "A firewall entry point, as it implements the  authenticationEntryPointInterface , must provided a  start  method which takes two parameters: a request and the exception previously raised.  start  must return a  Response  object that can be a page showing a form for instance.\nIf one of the  FirewallMap  Listener can handle the request, it creates a  Token  object that holds a reference to the current user, its roles and its credentials.\nThe listener then uses an  authenticationProviderManager  object to authenticate the  Token .  authenticationProviderManager  will authenticate the token if provided and return an  authenticated  one if the user credential is valid.  Otherwise an  AuthenticationException  is raised.\nEach  Token  uses a specific type of  authenticationProvider . An  authenticationProvider  must implements the  authenticationProviderInterface  and provides the two methods :   authentificate  which takes one paramater that must implements the  TokenInterface  and  supports  which is used to check whether or not the given  token  is supported by the authentication provider .  Registered FirewallMap Listeners must implement the  ListenerInterface  thus provided an  handle  method that accept an  GetRequestEvent  object.", 
            "title": "Authentication"
        }, 
        {
            "location": "/developer-documentation/components/security/#authorization", 
            "text": "Once a user is identified his roles or any other attributes or object of its  token  can be used to determine whether or not he has access to a resource.  Decision manager  An  AccessControlManager  is used to make final access decisions based on  Voter .  A voter can decide to  vote  either for grant or deny access to a ressource. A voter can also abstain itself.  By default The  AccessControllerManagers  make his decision according to one these three strategies:   affirmative  (Access is granted if any voter votes for granting access)  consensus  (Access is granted if there are more voters willing to granting access then otherwise  unanimous  (Access is granted if all voters vote for granting access)   Understand voters  A voter class must implements the  VoterInterface  which has 4 methods:   supportsAttribute($attribute)  supportsClass($class)  vote(TokentInterface $token, $object, $attributes)   supportsAttribute  is used to check if the voter supports some attributes of the token. supportClass  is user to check it the voter supports a specific class vote  handle the vote strategy and must return of those class Constant :   VoterInterface::ACCESS_GRANTED  VoterInterface::ACCESS_ABSTAIN  VoterInterface::ACCESS_DENIED   Bellow is list of Voter used in BackBee  AccessVoter  BBAclVoter  BBRoleVoter  SudoVoter", 
            "title": "Authorization"
        }, 
        {
            "location": "/developer-documentation/components/security/#backbee-securitycontext-and-the-contextinterface", 
            "text": "All the process of creating  Firewall ,  FirewallMap ,  AuthenticationManager ,  AccessDecisionMananger  and listeners is handled by the  BackBee\\Security\\SecurityContext  object.  However the way of dealing with security Listerners is simplyfied by using a  Context  object.\nA security  Context  extends the abstract class  BackBee\\Security\\Context\\BBAuthContext  and defines the  loadListeners  method.  LoadListeners  accepts one parameter which is the security config that can be setted in  repository/Config/security.yml .\nA context can be used to instanciate new listener or to register new authentication provider to the  SecuriryContext .  Bellow we show all the  security contexts provided by BackBee.   AnonymousContext  BBAuthContext  LogoutContext  RestfulContext  StatelessContext  UsernamePasswordContext   AnonymousContext  AnonymouseContext  is used to identify anonymous user.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\AnonymousAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\AnonymousToken   BBAuthContext  BBAuthContext  is used to authentify a user by using the BackBee User table.   authentication provider  :  BackBee\\Security\\Authentication\\Provider\\BBAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\AnonymousAuthenticationListener  Token  :  BackBee\\Security\\Token\\BBUserToken   LogoutContext  LogoutContext  handles user logout by removing all setted tokens.   authentication provider  :  none  Token  :  none  Listener :  BackBee\\Security\\Listeners\\LogoutListener   RestfulContext  RestfulContext  is used to authentify rest user with a plublic key.   authentication provider :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationProvider  Listener  :  BackBee\\Security\\Listeners\\PublicKeyAuthenticationListener  Token :  BackBee\\Security\\Token\\BBUserToken   StatelessContext  In stateless mode, authentication is asked for every requests.  StatelessContext  handles sessions\ncreation every time stateless mode is disabled.   authentication provider :  none  Listener :  BackBee\\Security\\Listeners\\ContextListener  Token :  none   UsernamePasswordContext  UsernamePasswordContext is used to authenticate user by using a login form.   authentication provider :  BackBee\\Security\\Listeners\\Provider\\UserAuthenticationProvider  Listener :  BackBee\\Security\\Listeners\\UsernamePasswordAuthenticationListener  Token :  BackBee\\Security\\Token\\UsernamePasswordToken", 
            "title": "BackBee SecurityContext and the ContextInterface"
        }, 
        {
            "location": "/developer-documentation/components/security/#configuring-security-with-securityyml", 
            "text": "Security configurations can be handled with a simple yml file. This file can be found in  repository/Config/security.yml .  firewalls:\n    bb_area:\n        pattern: ^/\n        requirements:\n            HTTP-X-Requested-With: XMLHttpRequest\n            HTTP-X-BB-METHOD: (JsonRpc|Upload)\n        provider: bb_user\n        bb_auth:\n            provider: bb_user\n            nonce_dir: security/nonces\n            lifetime: 1800\n            use_registry: true\n\nproviders:\n    bb_user:\n        entity:\n            class: BackBee\\Security\\User\n        secret: %secret_key%\n    public_key:\n        entity:\n            class: BackBee\\Security\\User\n\ncontexts:\n    BackBee\\Security\\Context: [StatelessContext, AnonymousContext, BBAuthContext, UsernamePasswordContext, LogoutContext, RestfulContext]\n\nencoders:\n    BackBee\\Security\\User:\n        class: Symfony\\Component\\Security\\Core\\Encoder\\MessageDigestPasswordEncoder\n        arguments:\n            algorithm: md5\n            encode_as_base64: false\n            iterations: 1\n\nacl:\n    connection: default", 
            "title": "Configuring Security with security.yml"
        }, 
        {
            "location": "/developer-documentation/components/translation/", 
            "text": "Components\n\n\nThe Translation Component\n\n\nThis component is used in BackBee to translate text into differents languages. Note this component is an extension of \nSymfony Translation Component\n\n\nHow the translation work\n\n\nBackBee translation component override \nSymfony\\Component\\Translation\\Translator\n to lazy load every catalogs from:\n- BackBee\\Resources\\translations\n- PATH_TO_REPOSITORY\\Resources\\translations\n- PATH_TO_CONTEXT_REPOSITORY\\Resources\\translations.\n\n\nBackBee use \nXLIFF\n catalogs to translate statics contents into your templates.\n\n\nConfiguration\n\n\nBackBee become with own is catalog and it can be extended without configuration if you put your catalog into the folder \nrepository/translations\n, the file need some naming convention \nmessages.{locale}.xlf\n you need to adapt \n{locale}\n with one real locale like en, fr, etc.\n\n\nYou configure the default locale of the site in \nencoding.yml\n into \nrepository/Config\n folder. By default the value is \n~\n and is corresponding to \nen_US\n locale.\n\n\nThe Catalog\n\n\nFirst step will go to create our first catalog and need to follow the Oasis XLIFF specifications.\n\n\n?xml version=\n1.0\n?\n\n\nxliff version=\n1.2\n xmlns=\nurn:oasis:names:tc:xliff:document:1.2\n\n    \nfile source-language=\nen\n datatype=\nplaintext\n original=\nfile.ext\n\n        \nbody\n\n            \ntrans-unit id=\n1\n\n                \nsource\nhello.backbee\n/source\n\n                \ntarget\nHello BackBee !\n/target\n\n            \n/trans-unit\n\n        \n/body\n\n    \n/file\n\n\n/xliff\n\n\n\n\n\n\n\nIn this  catalog case we define that the string \nhello.backbee\n will be translate into \nHello BackBee !\n\n\n\n\nUse translation\n\n\nIn template you can access to the translator by the global \nbb\n and you can use is function \ntrans\n to translate your string.\n\n\n{{ bb.translator.trans('hello.backbee') }}\n\n\n\n\nThis will return \"Hello BackBee !\".\n\n\nFor using it out of the template you need to access to the Dependencies Invection Container and then you can use the \ntrans\n method.\n\n\n$translator = $this-\ngetApplication()-\ngetContainer()-\nget('translator');\n\n$translator-\ntrans('hello.backbee');\n\n\n\n\n\n\nthe getApplication method is depending in the context where you run your translation.\n\n\nIf you are in an event listener you need to  do \n$this-\ngetEventDispatcher()-\ngetApplication()-\n...\n\n\n\n\nLike before the result will be \"Hello BackBee !\".\n\n\nIf you want do some more advanced usage of the component translation you will found more information on \nSymfony Translation Component Usage Documentation", 
            "title": "Translation"
        }, 
        {
            "location": "/developer-documentation/components/translation/#components", 
            "text": "", 
            "title": "Components"
        }, 
        {
            "location": "/developer-documentation/components/translation/#the-translation-component", 
            "text": "This component is used in BackBee to translate text into differents languages. Note this component is an extension of  Symfony Translation Component  How the translation work  BackBee translation component override  Symfony\\Component\\Translation\\Translator  to lazy load every catalogs from:\n- BackBee\\Resources\\translations\n- PATH_TO_REPOSITORY\\Resources\\translations\n- PATH_TO_CONTEXT_REPOSITORY\\Resources\\translations.  BackBee use  XLIFF  catalogs to translate statics contents into your templates.  Configuration  BackBee become with own is catalog and it can be extended without configuration if you put your catalog into the folder  repository/translations , the file need some naming convention  messages.{locale}.xlf  you need to adapt  {locale}  with one real locale like en, fr, etc.  You configure the default locale of the site in  encoding.yml  into  repository/Config  folder. By default the value is  ~  and is corresponding to  en_US  locale.  The Catalog  First step will go to create our first catalog and need to follow the Oasis XLIFF specifications.  ?xml version= 1.0 ?  xliff version= 1.2  xmlns= urn:oasis:names:tc:xliff:document:1.2 \n     file source-language= en  datatype= plaintext  original= file.ext \n         body \n             trans-unit id= 1 \n                 source hello.backbee /source \n                 target Hello BackBee ! /target \n             /trans-unit \n         /body \n     /file  /xliff    In this  catalog case we define that the string  hello.backbee  will be translate into  Hello BackBee !   Use translation  In template you can access to the translator by the global  bb  and you can use is function  trans  to translate your string.  {{ bb.translator.trans('hello.backbee') }}  This will return \"Hello BackBee !\".  For using it out of the template you need to access to the Dependencies Invection Container and then you can use the  trans  method.  $translator = $this- getApplication()- getContainer()- get('translator');\n\n$translator- trans('hello.backbee');   the getApplication method is depending in the context where you run your translation.  If you are in an event listener you need to  do  $this- getEventDispatcher()- getApplication()- ...   Like before the result will be \"Hello BackBee !\".  If you want do some more advanced usage of the component translation you will found more information on  Symfony Translation Component Usage Documentation", 
            "title": "The Translation Component"
        }
    ]
}